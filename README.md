
# OWASP Top 10 (2021) - Spring Framework

## A01:2021 Broken Access Control

<details>
<summary> ğŸ”´ 1. ZagroÅ¼enia zwiÄ…zane z lokalnym wÅ‚Ä…czeniem plikÃ³w (Local File Inclusion, LFI)</summary>

### Opis
Local File Inclusion (LFI) to podatnoÅ›Ä‡ umoÅ¼liwiajÄ…ca nieautoryzowany dostÄ™p do lokalnych plikÃ³w na serwerze. W Springu moÅ¼e wystÄ…piÄ‡, gdy dane wejÅ›ciowe uÅ¼ytkownika sÄ… przekazywane bez walidacji jako Å›cieÅ¼ka do pliku i uÅ¼ywane do dynamicznego Å‚adowania zasobÃ³w za pomocÄ… klas takich jak `Files` czy `Paths`.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@GetMapping("/loadFile")
public ResponseEntity<String> loadFile(@RequestParam String filePath) throws IOException {
    // UÅ¼ytkownik moÅ¼e dostarczyÄ‡ dowolnÄ… Å›cieÅ¼kÄ™, np. "../etc/passwd"
    Path path = Paths.get(filePath);
    String content = Files.readString(path); // Brak weryfikacji, czy Å›cieÅ¼ka jest bezpieczna
    return ResponseEntity.ok(content);
}
```

**Dlaczego podatny?**  
- Spring umoÅ¼liwia dynamiczne przetwarzanie parametrÃ³w Å¼Ä…dania (np. `@RequestParam`), co przy braku walidacji pozwala na manipulacjÄ™ Å›cieÅ¼kami i dostÄ™p do nieautoryzowanych plikÃ³w.

---

### Skutki
- MoÅ¼liwoÅ›Ä‡ odczytu plikÃ³w systemowych (np. `/etc/passwd`).
- Ujawnienie wraÅ¼liwych informacji, takich jak hasÅ‚a lub klucze.

---

### Zalecenia
```java
@GetMapping("/loadFile")
public ResponseEntity<String> loadFile(@RequestParam String fileName) throws IOException {
    // Definiujemy bezpieczny katalog
    Path safeDirectory = Paths.get("safeDir").toAbsolutePath();
    // Tworzymy Å›cieÅ¼kÄ™ dla pliku i normalizujemy jÄ…
    Path filePath = safeDirectory.resolve(fileName).normalize();

    // Weryfikujemy, czy plik znajduje siÄ™ w dozwolonym katalogu
    if (!filePath.startsWith(safeDirectory)) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Access denied");
    }

    String content = Files.readString(filePath);
    return ResponseEntity.ok(content);
}
```

**Dlaczego bezpieczny?**  
- Ogranicza dostÄ™p do katalogu `safeDir`.
- UÅ¼ywa `normalize`, aby zapobiec manipulacji Å›cieÅ¼kami typu `../`.

---

### Mechanizmy Spring Security
1. **Ograniczenie dostÄ™pu do zasobÃ³w**:
   ```java
   @Configuration
   @EnableWebSecurity
   public class SecurityConfig extends WebSecurityConfigurerAdapter {
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           // Ustawiamy reguÅ‚y dostÄ™pu:
           // - dostÄ™p do Å›cieÅ¼ek w katalogu "safeDir" jest dozwolony
           // - pozostaÅ‚e Å›cieÅ¼ki sÄ… blokowane
           http.authorizeRequests()
               .antMatchers("/safeDir/**").permitAll() // Dozwolone tylko "safeDir"
               .anyRequest().denyAll(); // Wszystko inne jest blokowane
       }
   }
   ```
   **Dlaczego bezpieczny?**  
   - ReguÅ‚y Spring Security kontrolujÄ… dostÄ™p do endpointÃ³w, ograniczajÄ…c dostÄ™p do katalogÃ³w.

</details>

<details>
<summary> ğŸ”´ 2. ZagroÅ¼enia zwiÄ…zane z dostÄ™pem do obiektÃ³w poprzez middleware (Object access middleware)</summary>

### Opis
PodatnoÅ›ci w Springu zwiÄ…zane z dostÄ™pem do obiektÃ³w mogÄ… wystÄ…piÄ‡, gdy brak jest walidacji danych uÅ¼ytkownika lub kontroli dostÄ™pu. PrzykÅ‚adowo, brak weryfikacji uÅ¼ytkownika przy pobieraniu danych za pomocÄ… metod serwisowych moÅ¼e prowadziÄ‡ do eskalacji uprawnieÅ„.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@GetMapping("/getUserData")
public ResponseEntity<UserData> getUserData(@RequestParam Long userId) {
    // Metoda pobiera dane dowolnego uÅ¼ytkownika bez sprawdzania uprawnieÅ„
    UserData userData = userService.findById(userId); 
    return ResponseEntity.ok(userData);
}
```

**Dlaczego podatny?**  
- Brak weryfikacji, czy zalogowany uÅ¼ytkownik jest wÅ‚aÅ›cicielem danych, ktÃ³re chce uzyskaÄ‡.
- Spring umoÅ¼liwia Å‚atwe mapowanie parametrÃ³w (np. `@RequestParam`), ale to programista odpowiada za kontrolÄ™ dostÄ™pu.

---

### Skutki
- Nieautoryzowany dostÄ™p do danych innego uÅ¼ytkownika.
- Naruszenie poufnoÅ›ci danych.

---

### Zalecenia
```java
@GetMapping("/getUserData")
public ResponseEntity<UserData> getUserData(@RequestParam Long userId, Principal principal) {
    // Pobieramy nazwÄ™ uÅ¼ytkownika z kontekstu bezpieczeÅ„stwa
    String currentUsername = principal.getName();
    UserData userData = userService.findById(userId);

    // Sprawdzamy, czy zalogowany uÅ¼ytkownik ma dostÄ™p do danych
    if (!userData.getUsername().equals(currentUsername)) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(null);
    }

    return ResponseEntity.ok(userData);
}
```

**Dlaczego bezpieczny?**  
- Sprawdza, czy dane naleÅ¼Ä… do uÅ¼ytkownika wysyÅ‚ajÄ…cego Å¼Ä…danie.

---

### Mechanizmy Spring Security
1. **Weryfikacja uprawnieÅ„ za pomocÄ… adnotacji**:
   ```java
   @Service
   public class UserService {
       // Adnotacja @PreAuthorize sprawdza, czy ID uÅ¼ytkownika pasuje do ID z kontekstu
       @PreAuthorize("#userId == authentication.principal.id")
       public UserData getUserData(Long userId) {
           return userRepository.findById(userId)
               .orElseThrow(() -> new RuntimeException("User not found"));
       }
   }
   ```
   **Dlaczego bezpieczny?**  
   - Adnotacja `@PreAuthorize` weryfikuje uprawnienia przed wykonaniem metody.

</details>

<details>
<summary>3. ZagroÅ¼enia zwiÄ…zane z masowym przypisywaniem (Mass Assignment)</summary>

### Opis
Mass Assignment w Springu moÅ¼e wystÄ…piÄ‡, gdy dane wejÅ›ciowe sÄ… mapowane bezpoÅ›rednio na obiekt modelu (np. `@RequestBody`). PrzykÅ‚adowo, uÅ¼ytkownik moÅ¼e manipulowaÄ‡ przesyÅ‚anymi danymi, aby zmieniÄ‡ pola, do ktÃ³rych nie powinien mieÄ‡ dostÄ™pu.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@PostMapping("/updateUser")
public ResponseEntity<String> updateUser(@RequestBody User user) {
    // BezpoÅ›rednie przypisanie danych uÅ¼ytkownika z Å¼Ä…dania do modelu
    userRepository.save(user); // Brak kontroli nad modyfikowanymi polami
    return ResponseEntity.ok("User updated");
}
```

**Dlaczego podatny?**  
- Spring automatycznie mapuje dane JSON na obiekt, co pozwala na nieautoryzowane zmiany, np. ustawienie pola `role`.

---

### Skutki
- Nieautoryzowane modyfikacje wraÅ¼liwych pÃ³l, takich jak role uÅ¼ytkownika.
- MoÅ¼liwoÅ›Ä‡ eskalacji uprawnieÅ„.

---

### Zalecenia
```java
@PostMapping("/updateUser")
public ResponseEntity<String> updateUser(@RequestBody UserDto userDto, Principal principal) {
    // Pobieramy dane zalogowanego uÅ¼ytkownika
    User currentUser = userRepository.findByUsername(principal.getName());

    // RÄ™czne przypisanie tylko wybranych pÃ³l
    currentUser.setName(userDto.getName());
    currentUser.setEmail(userDto.getEmail());

    userRepository.save(currentUser);
    return ResponseEntity.ok("User updated");
}
```

**Dlaczego bezpieczny?**  
- Wykorzystuje DTO do ograniczenia modyfikowanych pÃ³l.
- Zapewnia peÅ‚nÄ… kontrolÄ™ nad procesem aktualizacji.

---

### Mechanizmy Spring Security
1. **Walidacja danych wejÅ›ciowych za pomocÄ… DTO**:
   ```java
   public class UserDto {
       @NotBlank
       private String name;

       @Email
       private String email;
   }
   ```

2. **Bezpieczne mapowanie danych w kontrolerze**:
   ```java
   @PostMapping("/updateUser")
   public ResponseEntity<String> updateUser(@Valid @RequestBody UserDto userDto) {
       // Tylko dane zgodne z DTO zostanÄ… zaakceptowane
       return ResponseEntity.ok("User updated");
   }
   ```

</details>

<details>
<summary>ğŸ”´ 4. Insecure Direct Object Reference (IDOR)</summary>

### Opis
Insecure Direct Object Reference (IDOR) to podatnoÅ›Ä‡, ktÃ³ra wystÄ™puje, gdy aplikacja pozwala uÅ¼ytkownikowi na bezpoÅ›redni dostÄ™p do zasobÃ³w (np. rekordÃ³w w bazie danych) za pomocÄ… identyfikatorÃ³w, takich jak ID. W Springu podatnoÅ›Ä‡ ta moÅ¼e wystÄ…piÄ‡, jeÅ›li parametry takie jak `@RequestParam` czy `@PathVariable` nie sÄ… odpowiednio weryfikowane w kontekÅ›cie dostÄ™pu uÅ¼ytkownika do danego zasobu.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@GetMapping("/documents/{docId}")
public ResponseEntity<Document> getDocument(@PathVariable Long docId) {
    // Pobieramy dokument z bazy danych na podstawie ID przekazanego w Å¼Ä…daniu
    Document document = documentRepository.findById(docId)
            .orElseThrow(() -> new RuntimeException("Document not found"));
    return ResponseEntity.ok(document);
}
```

**Dlaczego podatny?**  
- UÅ¼ytkownik moÅ¼e manipulowaÄ‡ parametrem `docId` w Å¼Ä…daniu, aby uzyskaÄ‡ dostÄ™p do dokumentÃ³w, do ktÃ³rych nie powinien mieÄ‡ dostÄ™pu.
- Brak weryfikacji, czy zalogowany uÅ¼ytkownik ma uprawnienia do danego zasobu.

---

### Skutki
- Nieautoryzowany dostÄ™p do danych innych uÅ¼ytkownikÃ³w.
- Ujawnienie poufnych informacji, takich jak dokumenty, dane osobowe czy transakcje.

---

### Zalecenia
```java
@GetMapping("/documents/{docId}")
public ResponseEntity<Document> getDocument(@PathVariable Long docId, Principal principal) {
    // Pobieramy nazwÄ™ uÅ¼ytkownika z kontekstu bezpieczeÅ„stwa
    String currentUsername = principal.getName();

    // Pobieramy dokument z bazy danych
    Document document = documentRepository.findById(docId)
            .orElseThrow(() -> new RuntimeException("Document not found"));

    // Sprawdzamy, czy dokument naleÅ¼y do zalogowanego uÅ¼ytkownika
    if (!document.getOwner().equals(currentUsername)) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(null);
    }

    return ResponseEntity.ok(document);
}
```

**Dlaczego bezpieczny?**  
- Weryfikuje, czy dokument naleÅ¼y do zalogowanego uÅ¼ytkownika.
- Ogranicza dostÄ™p do zasobÃ³w na podstawie toÅ¼samoÅ›ci uÅ¼ytkownika.

---

### Mechanizmy Spring Security
1. **Kontrola dostÄ™pu z uÅ¼yciem `@PreAuthorize`**:
   ```java
   @Service
   public class DocumentService {
       // Adnotacja weryfikuje, czy uÅ¼ytkownik jest wÅ‚aÅ›cicielem dokumentu przed wykonaniem metody
       @PreAuthorize("@documentSecurityService.isOwner(#docId, authentication.name)")
       public Document getDocument(Long docId) {
           return documentRepository.findById(docId)
                   .orElseThrow(() -> new RuntimeException("Document not found"));
       }
   }

   @Component
   public class DocumentSecurityService {
       public boolean isOwner(Long docId, String username) {
           Document document = documentRepository.findById(docId).orElse(null);
           return document != null && document.getOwner().equals(username);
       }
   }
   ```

   **Dlaczego bezpieczny?**  
   - Adnotacja `@PreAuthorize` wymusza weryfikacjÄ™ uprawnieÅ„ przed wykonaniem metody.
   - Logika w klasie `DocumentSecurityService` dokÅ‚adnie sprawdza, czy uÅ¼ytkownik jest wÅ‚aÅ›cicielem zasobu.

2. **Definiowanie rÃ³l i reguÅ‚ dostÄ™pu**:
   ```java
   @Override
   protected void configure(HttpSecurity http) throws Exception {
       http.authorizeRequests()
           .antMatchers("/documents/**").authenticated() // DostÄ™p do dokumentÃ³w tylko dla zalogowanych uÅ¼ytkownikÃ³w
           .anyRequest().denyAll();
   }
   ```

   **Dlaczego bezpieczny?**  
   - Ogranicza dostÄ™p do endpointÃ³w tylko dla uwierzytelnionych uÅ¼ytkownikÃ³w.
   - Blokuje nieautoryzowany dostÄ™p do wszystkich innych zasobÃ³w.

</details>

## A02:2021 Cryptographic Failures

<details>
<summary>ğŸ”´ 1. Weak Encoding for Password</summary>

### Opis
PodatnoÅ›Ä‡ zwiÄ…zana z niewÅ‚aÅ›ciwym hashowaniem haseÅ‚ wystÄ™puje, gdy aplikacja uÅ¼ywa sÅ‚abych funkcji hashujÄ…cych, takich jak MD5 lub SHA-1, ktÃ³re sÄ… podatne na ataki siÅ‚owe (brute force) lub kolizje. W Springu ta podatnoÅ›Ä‡ moÅ¼e wystÄ…piÄ‡, jeÅ›li implementacja przechowywania haseÅ‚ nie wykorzystuje odpowiednich algorytmÃ³w, takich jak BCrypt.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@Service
public class UserService {

    // Hashowanie hasÅ‚a za pomocÄ… MD5 (sÅ‚aby algorytm)
    public String hashPassword(String password) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] hash = md.digest(password.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Error hashing password", e);
        }
    }
}
```

**Dlaczego podatny?**  
- MD5 jest przestarzaÅ‚ym algorytmem hashujÄ…cym, podatnym na ataki brute force i kolizje.
- Brak mechanizmu saltingu, co zwiÄ™ksza ryzyko zÅ‚amania haseÅ‚.

---

### Skutki
- Nieautoryzowany dostÄ™p do kont uÅ¼ytkownikÃ³w w przypadku zÅ‚amania haseÅ‚.
- Naruszenie poufnoÅ›ci danych.

---

### Zalecenia
```java
@Service
public class UserService {

    // Hashowanie hasÅ‚a za pomocÄ… BCrypt
    public String hashPassword(String password) {
        return new BCryptPasswordEncoder().encode(password);
    }
}
```

**Dlaczego bezpieczny?**  
- BCrypt zostaÅ‚ zaprojektowany specjalnie do przechowywania haseÅ‚, zapewniajÄ…c wbudowany mechanizm saltingu.
- Jego mechanizm adaptacyjny zwiÄ™ksza czas hashowania w miarÄ™ wzrostu mocy obliczeniowej atakujÄ…cych.

---

### Mechanizmy Spring Security
1. **UÅ¼ycie wbudowanego `PasswordEncoder`**:
   ```java
   @Configuration
   public class SecurityConfig {
       @Bean
       public PasswordEncoder passwordEncoder() {
           // Konfigurujemy BCryptPasswordEncoder jako domyÅ›lny mechanizm hashowania
           return new BCryptPasswordEncoder();
       }
   }
   ```

   **Dlaczego bezpieczny?**  
   - Spring Security rekomenduje uÅ¼ycie `BCryptPasswordEncoder`, ktÃ³ry jest zgodny z najlepszymi praktykami dotyczÄ…cymi przechowywania haseÅ‚.

2. **Weryfikacja hasÅ‚a**:
   ```java
   @Service
   public class AuthenticationService {
       @Autowired
       private PasswordEncoder passwordEncoder;

       public boolean verifyPassword(String rawPassword, String hashedPassword) {
           // Sprawdzanie hasÅ‚a za pomocÄ… BCrypt
           return passwordEncoder.matches(rawPassword, hashedPassword);
       }
   }
   ```

   **Dlaczego bezpieczny?**  
   - Funkcja `matches` zapewnia poprawne porÃ³wnanie hasÅ‚a w formie jawnej z jego wersjÄ… zahashowanÄ….

</details>

<details>
<summary> ğŸ”´ 2. Use of Hard-coded Cryptographic Key</summary>

### Opis
PodatnoÅ›Ä‡ zwiÄ…zana z uÅ¼ywaniem zaszytych na staÅ‚e (hard-coded) kluczy kryptograficznych wystÄ™puje, gdy aplikacja przechowuje klucz szyfrujÄ…cy bezpoÅ›rednio w kodzie ÅºrÃ³dÅ‚owym. MoÅ¼e to prowadziÄ‡ do ujawnienia klucza i umoÅ¼liwienia atakujÄ…cym odszyfrowania poufnych danych. W Springu problem ten moÅ¼e wystÄ…piÄ‡, gdy klucz jest zapisany w zmiennej w kodzie lub w plikach konfiguracyjnych bez odpowiedniego zabezpieczenia.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@Service
public class EncryptionService {

    // Zaszyty na staÅ‚e klucz kryptograficzny (podatny)
    private static final String SECRET_KEY = "hardcoded_key_12345";

    public String encrypt(String data) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        SecretKeySpec key = new SecretKeySpec(SECRET_KEY.getBytes(), "AES");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes()));
    }
}
```

**Dlaczego podatny?**  
- Klucz kryptograficzny jest zapisany w kodzie i moÅ¼e byÄ‡ Å‚atwo odczytany przez atakujÄ…cych.

---

### Skutki
- MoÅ¼liwoÅ›Ä‡ odszyfrowania poufnych danych przez osoby trzecie.
- Naruszenie poufnoÅ›ci danych uÅ¼ytkownikÃ³w.

---

### Zalecenia
```java
@Service
public class EncryptionService {

    // Klucz kryptograficzny jest przechowywany w bezpiecznym magazynie, np. w pliku konfiguracyjnym lub systemie zarzÄ…dzania sekretami
    @Value("${encryption.secret-key}")
    private String secretKey;

    public String encrypt(String data) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        SecretKeySpec key = new SecretKeySpec(secretKey.getBytes(), "AES");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes()));
    }
}
```

**Dlaczego bezpieczny?**  
- Klucz kryptograficzny jest przechowywany poza kodem ÅºrÃ³dÅ‚owym, np. w `application.properties` lub w systemie zarzÄ…dzania sekretami (Vault, AWS Secrets Manager).
- DostÄ™p do klucza jest ograniczony odpowiednimi mechanizmami uprawnieÅ„.

---

### Mechanizmy Spring Security
1. **Przechowywanie klucza w pliku konfiguracyjnym**:
   ```properties
   # application.properties
   encryption.secret-key=secure_random_generated_key
   ```

   **Dlaczego bezpieczne?**  
   - Plik konfiguracyjny moÅ¼e byÄ‡ chroniony odpowiednimi uprawnieniami dostÄ™pu do systemu operacyjnego.
   - Klucz nie jest zaszyty w kodzie, co utrudnia jego wyciek.

2. **UÅ¼ycie systemu zarzÄ…dzania sekretami**:
   - Integracja z narzÄ™dziami takimi jak HashiCorp Vault, AWS Secrets Manager czy Azure Key Vault.
   - PrzykÅ‚ad pobierania klucza z Vault:
     ```java
     @Service
     public class EncryptionService {

         @Autowired
         private VaultTemplate vaultTemplate;

         public String getSecretKey() {
             return vaultTemplate.read("secret/encryption").getData().get("key");
         }
     }
     ```

   **Dlaczego bezpieczne?**  
   - Klucz jest przechowywany w dedykowanym, bezpiecznym magazynie, a dostÄ™p do niego wymaga odpowiednich uprawnieÅ„.

</details>
<details>
<summary>ğŸ”´ 3. Cleartext Transmission of Sensitive Information</summary>

### Opis
PodatnoÅ›Ä‡ ta wystÄ™puje, gdy aplikacja przesyÅ‚a poufne informacje (np. dane logowania, dane osobowe, czy numery kart kredytowych) w formie jawnego tekstu (cleartext), bez odpowiedniego zabezpieczenia protokoÅ‚em szyfrowania, takim jak HTTPS. W Springu problem ten moÅ¼e wystÄ…piÄ‡, jeÅ›li endpointy sÄ… wystawione na HTTP zamiast HTTPS lub jeÅ›li wraÅ¼liwe dane sÄ… przesyÅ‚ane jako jawny tekst w odpowiedziach lub nagÅ‚Ã³wkach HTTP.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class LoginController {

    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestBody LoginRequest loginRequest) {
        // WraÅ¼liwe dane uÅ¼ytkownika sÄ… zwracane w jawny sposÃ³b
        return ResponseEntity.ok("User logged in with password: " + loginRequest.getPassword());
    }
}
```

**Dlaczego podatny?**  
- Endpoint `/login` jest dostÄ™pny przez HTTP, co umoÅ¼liwia przechwycenie danych podczas transmisji (np. za pomocÄ… ataku typu Man-in-the-Middle).
- HasÅ‚o uÅ¼ytkownika jest przesyÅ‚ane jako czÄ™Å›Ä‡ odpowiedzi w jawny sposÃ³b.

---

### Skutki
- PrzejÄ™cie poufnych danych uÅ¼ytkownika, takich jak login i hasÅ‚o.
- MoÅ¼liwoÅ›Ä‡ nieautoryzowanego dostÄ™pu do systemu.

---

### Zalecenia
```java
@RestController
public class LoginController {

    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestBody LoginRequest loginRequest) {
        // Minimalizujemy wraÅ¼liwe dane w odpowiedzi
        return ResponseEntity.ok("User logged in successfully.");
    }
}
```

**Dlaczego bezpieczny?**  
- WraÅ¼liwe informacje, takie jak hasÅ‚o, nie sÄ… przesyÅ‚ane w odpowiedzi.
- Dane sÄ… przesyÅ‚ane wyÅ‚Ä…cznie przez HTTPS, co zabezpiecza je przed przechwyceniem.

---

### Mechanizmy Spring Security
1. **Wymuszanie HTTPS**:
   - MoÅ¼na skonfigurowaÄ‡ aplikacjÄ™ Spring do wymuszania HTTPS, dodajÄ…c poniÅ¼szÄ… konfiguracjÄ™:
   ```java
   @Configuration
   public class SecurityConfig extends WebSecurityConfigurerAdapter {

       @Override
       protected void configure(HttpSecurity http) throws Exception {
           http.requiresChannel()
               .anyRequest()
               .requiresSecure(); // Wymusza HTTPS dla wszystkich Å¼Ä…daÅ„
       }
   }
   ```

   **Dlaczego bezpieczne?**  
   - Spring Security automatycznie przekierowuje wszystkie Å¼Ä…dania HTTP na HTTPS.

2. **Dodanie certyfikatu SSL w `application.properties`**:
   ```properties
   server.ssl.key-store=classpath:keystore.p12
   server.ssl.key-store-password=yourPassword
   server.ssl.key-store-type=PKCS12
   server.port=8443
   ```

   **Dlaczego bezpieczne?**  
   - Dane sÄ… szyfrowane podczas transmisji przy uÅ¼yciu protokoÅ‚u HTTPS z certyfikatem SSL/TLS.
</details>

## A03:2021 Injection

<details>
<summary>ğŸ”´ 1. Remote Code Execution (RCE)</summary>

### Opis
Remote Code Execution (RCE) to podatnoÅ›Ä‡, ktÃ³ra pozwala atakujÄ…cemu na wstrzykniÄ™cie i wykonanie dowolnego kodu na serwerze. W Springu ta podatnoÅ›Ä‡ moÅ¼e wystÄ…piÄ‡ w dwÃ³ch gÅ‚Ã³wnych kontekstach:
1. **Spring Expression Language (SpEL):** JeÅ›li uÅ¼ytkownik ma kontrolÄ™ nad wyraÅ¼eniami SpEL i sÄ… one wykonywane bez ograniczeÅ„.
2. **Deserializacja obiektÃ³w:** Gdy aplikacja deserializuje niezaufane dane bez odpowiedniej walidacji.

---

### PrzykÅ‚ad podatnoÅ›ci: SpEL
```java
@RestController
public class SpELController {

    @PostMapping("/evaluate")
    public ResponseEntity<String> evaluateExpression(@RequestParam String expression) {
        // Wykonanie wyraÅ¼enia SpEL dostarczonego przez uÅ¼ytkownika
        ExpressionParser parser = new SpelExpressionParser();
        Expression exp = parser.parseExpression(expression);
        String result = exp.getValue().toString();
        return ResponseEntity.ok("Result: " + result);
    }
}
```

**Dlaczego podatny?**  
- UÅ¼ytkownik moÅ¼e wstrzyknÄ…Ä‡ zÅ‚oÅ›liwe wyraÅ¼enie SpEL, takie jak `T(java.lang.Runtime).getRuntime().exec("rm -rf /")`, co pozwoli na wykonanie dowolnego polecenia systemowego.

---

### PrzykÅ‚ad podatnoÅ›ci: Deserializacja obiektÃ³w
```java
@RestController
public class DeserializationController {

    @PostMapping("/deserialize")
    public ResponseEntity<Object> deserialize(@RequestBody byte[] data) throws IOException, ClassNotFoundException {
        // Deserializacja danych dostarczonych przez uÅ¼ytkownika
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));
        Object obj = ois.readObject();
        return ResponseEntity.ok(obj);
    }
}
```

**Dlaczego podatny?**  
- Deserializacja niezaufanych danych umoÅ¼liwia atakujÄ…cemu dostarczenie zÅ‚oÅ›liwego obiektu, ktÃ³ry moÅ¼e wykonaÄ‡ niebezpieczne operacje, takie jak otwieranie poÅ‚Ä…czeÅ„ sieciowych lub modyfikacja plikÃ³w.

---

### Skutki
- Wykonanie dowolnego kodu na serwerze.
- PrzejÄ™cie kontroli nad aplikacjÄ… lub serwerem.
- Utrata poufnoÅ›ci, integralnoÅ›ci lub dostÄ™pnoÅ›ci danych.

---

### Zalecenia: SpEL
```java
@RestController
public class SpELController {

    @PostMapping("/evaluate")
    public ResponseEntity<String> evaluateExpression(@RequestParam String expression) {
        // Ograniczenie wyraÅ¼eÅ„ SpEL do prostych operacji matematycznych
        if (!expression.matches("[0-9+\-*/()]*")) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Invalid expression");
        }

        ExpressionParser parser = new SpelExpressionParser();
        Expression exp = parser.parseExpression(expression);
        String result = exp.getValue().toString();
        return ResponseEntity.ok("Result: " + result);
    }
}
```

**Dlaczego bezpieczny?**  
- Ogranicza dopuszczalne wyraÅ¼enia do prostych operacji matematycznych.
- Nie pozwala na wykonanie potencjalnie niebezpiecznych wyraÅ¼eÅ„ SpEL.

---

### Zalecenia: Deserializacja
```java
@RestController
public class DeserializationController {

    @PostMapping("/deserialize")
    public ResponseEntity<Object> deserialize(@RequestBody byte[] data) throws IOException, ClassNotFoundException {
        // Zastosowanie biaÅ‚ej listy dozwolonych klas
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data)) {
            @Override
            protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
                if (!"com.example.SafeClass".equals(desc.getName())) {
                    throw new InvalidClassException("Unauthorized deserialization attempt: " + desc.getName());
                }
                return super.resolveClass(desc);
            }
        };

        Object obj = ois.readObject();
        return ResponseEntity.ok(obj);
    }
}
```

**Dlaczego bezpieczny?**  
- Implementuje biaÅ‚Ä… listÄ™ klas, ktÃ³re mogÄ… byÄ‡ deserializowane.
- UniemoÅ¼liwia wykonanie zÅ‚oÅ›liwych obiektÃ³w dostarczonych przez atakujÄ…cego.

---

### Mechanizmy Spring Security
1. **WyÅ‚Ä…cz SpEL w miejscach, gdzie jest to moÅ¼liwe**:
   - JeÅ›li SpEL nie jest konieczne, ogranicz jego uÅ¼ycie w konfiguracji Springa lub uÅ¼yj bardziej ograniczonych wyraÅ¼eÅ„.

2. **Walidacja danych wejÅ›ciowych**:
   - Weryfikuj i waliduj dane wejÅ›ciowe uÅ¼ytkownika przed ich przetwarzaniem.
   ```java
   @PostMapping("/evaluate")
   public ResponseEntity<String> validateAndEvaluate(@RequestParam @Pattern(regexp = "[0-9+\-*/()]*") String expression) {
       // Przetwarzanie wyraÅ¼enia po walidacji
       return ResponseEntity.ok("Validated and processed");
   }
   ```

3. **Unikaj deserializacji niezaufanych danych**:
   - Korzystaj z bezpiecznych formatÃ³w przesyÅ‚ania danych, takich jak JSON czy protokoÅ‚y typu Protobuf, zamiast Java Serialization.

</details>

<details>
<summary>ğŸ”´ 2. Cross-Site Scripting (XSS)</summary>

### Opis
Cross-Site Scripting (XSS) to podatnoÅ›Ä‡, ktÃ³ra wystÄ™puje, gdy aplikacja wstrzykuje niesprawdzone dane uÅ¼ytkownika do odpowiedzi HTML, umoÅ¼liwiajÄ…c wykonanie zÅ‚oÅ›liwego kodu JavaScript w przeglÄ…darce ofiary. W Springu podatnoÅ›Ä‡ ta moÅ¼e wystÄ…piÄ‡, jeÅ›li dane wejÅ›ciowe uÅ¼ytkownika sÄ… bezpoÅ›rednio renderowane na stronie bez odpowiedniego zabezpieczenia.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class XSSController {

    @GetMapping("/greet")
    public String greetUser(@RequestParam String name) {
        // BezpoÅ›rednie wstawienie danych uÅ¼ytkownika w odpowiedzi HTML
        return "<html><body>Hello, " + name + "!</body></html>";
    }
}
```

**Dlaczego podatny?**  
- Dane wejÅ›ciowe uÅ¼ytkownika (`name`) sÄ… wstawiane bez walidacji lub escapingu.
- AtakujÄ…cy moÅ¼e przesÅ‚aÄ‡ zÅ‚oÅ›liwy kod, np. `<script>alert('Hacked!')</script>`, ktÃ³ry zostanie wykonany w przeglÄ…darce uÅ¼ytkownika.

---

### Skutki
- Wykonanie zÅ‚oÅ›liwego kodu JavaScript w przeglÄ…darce ofiary.
- KradzieÅ¼ danych sesyjnych lub poufnych informacji.
- Podszywanie siÄ™ pod uÅ¼ytkownika (session hijacking).

---

### Zalecenia
1. **Escaping danych wyjÅ›ciowych**:
   ```java
   @RestController
   public class XSSController {

       @GetMapping("/greet")
       public String greetUser(@RequestParam String name) {
           // Escaping danych uÅ¼ytkownika
           String escapedName = HtmlUtils.htmlEscape(name);
           return "<html><body>Hello, " + escapedName + "!</body></html>";
       }
   }
   ```

   **Dlaczego bezpieczny?**  
   - Funkcja `HtmlUtils.htmlEscape` zamienia specjalne znaki na ich bezpieczne odpowiedniki HTML (np. `<` na `&lt;`).

2. **UÅ¼ycie szablonÃ³w JSP lub Thymeleaf z automatycznym escapowaniem**:
   - Thymeleaf automatycznie escapuje dane uÅ¼ytkownika:
     ```html
     <p th:text="${name}">Hello, User!</p>
     ```

---

### Mechanizmy Spring Security
1. **SecurityFilterChain**:
   - Spring Security domyÅ›lnie zapewnia ochronÄ™ przed XSS za pomocÄ… `SecurityFilterChain`, ktÃ³ry filtruje dane wejÅ›ciowe i odpowiedzi HTTP.
   - Konfiguracja w Spring Boot:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http
                 .csrf() // WÅ‚Ä…cz ochronÄ™ przed CSRF
                 .and()
                 .headers()
                 .xssProtection()
                 .block(false); // WÅ‚Ä…cza podstawowe zabezpieczenia XSS
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - `SecurityFilterChain` automatycznie filtruje i blokuje potencjalne ataki XSS.

2. **UÅ¼ycie CSP (Content Security Policy)**:
   - Dodanie nagÅ‚Ã³wka Content-Security-Policy do odpowiedzi:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http
                 .headers()
                 .contentSecurityPolicy("script-src 'self'");
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - CSP ogranicza moÅ¼liwoÅ›Ä‡ wykonywania skryptÃ³w tylko do zaufanych ÅºrÃ³deÅ‚.

3. **Walidacja danych wejÅ›ciowych**:
   - Waliduj dane uÅ¼ytkownika przed ich przetwarzaniem:
     ```java
     @GetMapping("/greet")
     public String validateAndGreetUser(@RequestParam @Size(max = 50) String name) {
         return "<html><body>Hello, " + HtmlUtils.htmlEscape(name) + "!</body></html>";
     }
     ```

     **Dlaczego bezpieczne?**  
     - Walidacja ogranicza wielkoÅ›Ä‡ i zakres akceptowanych danych wejÅ›ciowych.

</details>

<details>
<summary>ğŸ”´ 3. Cross-Site Request Forgery (CSRF)</summary>

### Opis
Cross-Site Request Forgery (CSRF) to podatnoÅ›Ä‡, w ktÃ³rej atakujÄ…cy wykorzystuje uwierzytelnionÄ… sesjÄ™ uÅ¼ytkownika do wykonania nieautoryzowanych akcji w aplikacji webowej. W Springu podatnoÅ›Ä‡ ta moÅ¼e wystÄ…piÄ‡, jeÅ›li aplikacja nie stosuje tokenÃ³w CSRF lub gdy endpointy API sÄ… niewÅ‚aÅ›ciwie chronione.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class CSRFController {

    @PostMapping("/transfer")
    public ResponseEntity<String> transferFunds(@RequestParam String account, @RequestParam double amount) {
        // Brak weryfikacji, czy Å¼Ä…danie pochodzi od autoryzowanego uÅ¼ytkownika
        return ResponseEntity.ok("Transferred " + amount + " to " + account);
    }
}
```

**Dlaczego podatny?**  
- Endpoint `/transfer` nie wymaga Å¼adnego mechanizmu weryfikacji, czy Å¼Ä…danie pochodzi z zaufanego ÅºrÃ³dÅ‚a.
- AtakujÄ…cy moÅ¼e osadziÄ‡ zÅ‚oÅ›liwy formularz HTML w swojej witrynie, aby wymusiÄ‡ Å¼Ä…danie na uwierzytelnionym uÅ¼ytkowniku.

---

### Skutki
- Nieautoryzowane wykonanie akcji, takich jak przelewy, zmiana danych uÅ¼ytkownika lub modyfikacja ustawieÅ„.
- Naruszenie integralnoÅ›ci i bezpieczeÅ„stwa danych.

---

### Zalecenia
1. **WÅ‚Ä…czenie ochrony CSRF w Spring Security**:
   - DomyÅ›lnie Spring Security chroni przed CSRF. MoÅ¼na to skonfigurowaÄ‡ w `SecurityFilterChain`:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http
                 .csrf() // WÅ‚Ä…cza ochronÄ™ przed CSRF
                 .and()
                 .authorizeRequests()
                 .anyRequest().authenticated(); // Wszystkie Å¼Ä…dania muszÄ… byÄ‡ uwierzytelnione
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Token CSRF jest generowany dla kaÅ¼dego Å¼Ä…dania i weryfikowany na serwerze.

2. **UÅ¼ycie tokenÃ³w CSRF w Å¼Ä…daniach**:
   - Token CSRF naleÅ¼y przesyÅ‚aÄ‡ w kaÅ¼dym Å¼Ä…daniu POST:
     ```html
     <form method="POST" action="/transfer">
         <input type="hidden" name="_csrf" value="${_csrf.token}" />
         <input type="text" name="account" placeholder="Account" />
         <input type="number" name="amount" placeholder="Amount" />
         <button type="submit">Transfer</button>
     </form>
     ```

     **Dlaczego bezpieczne?**  
     - Serwer weryfikuje poprawnoÅ›Ä‡ tokenu CSRF przed wykonaniem akcji.

3. **WyÅ‚Ä…czanie ochrony CSRF dla endpointÃ³w API (jeÅ›li to konieczne)**:
   - JeÅ›li API korzysta z tokenÃ³w uwierzytelniajÄ…cych, moÅ¼na wyÅ‚Ä…czyÄ‡ CSRF:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http
                 .csrf().disable() // WyÅ‚Ä…cza CSRF dla REST API
                 .authorizeRequests()
                 .anyRequest().authenticated(); // Wszystkie Å¼Ä…dania muszÄ… byÄ‡ uwierzytelnione
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Tokeny uwierzytelniajÄ…ce (np. JWT) zastÄ™pujÄ… funkcjÄ™ tokenÃ³w CSRF w przypadku API.

4. **Dodanie nagÅ‚Ã³wkÃ³w `SameSite` dla ciasteczek**:
   - Ustaw nagÅ‚Ã³wek `SameSite` na `Strict` lub `Lax`:
     ```java
     @Bean
     public WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> cookieConfig() {
         return factory -> factory.addInitializers(
             new WebServerInitializer(new SameSiteCookieConfig("Strict")));
     }
     ```

     **Dlaczego bezpieczne?**  
     - Ciasteczka nie sÄ… przesyÅ‚ane w Å¼Ä…daniach pochodzÄ…cych z innych domen.

</details>

<details>
<summary>ğŸ”´ 4. SQL Injection (SQLi)</summary>

### Opis
SQL Injection (SQLi) to podatnoÅ›Ä‡, w ktÃ³rej atakujÄ…cy wstrzykuje zÅ‚oÅ›liwy kod SQL do zapytania, manipulujÄ…c danymi wejÅ›ciowymi. W Spring Data JPA problem ten moÅ¼e wystÄ…piÄ‡, gdy programista uÅ¼ywa zapytaÅ„ dynamicznych zbudowanych w oparciu o dane uÅ¼ytkownika bez ich odpowiedniego zabezpieczenia.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@Repository
public class UserRepository {

    @PersistenceContext
    private EntityManager entityManager;

    public List<User> findByUsername(String username) {
        // Dynamiczne zapytanie SQL z wstrzykniÄ™tymi danymi uÅ¼ytkownika
        String query = "SELECT u FROM User u WHERE u.username = '" + username + "'";
        return entityManager.createQuery(query, User.class).getResultList();
    }
}
```

**Dlaczego podatny?**  
- UÅ¼ytkownik moÅ¼e przesÅ‚aÄ‡ zÅ‚oÅ›liwy ciÄ…g znakÃ³w, np. `' OR '1'='1`, co spowoduje wykonanie zÅ‚oÅ›liwego zapytania SQL, zwracajÄ…c wszystkie rekordy w tabeli.

---

### Skutki
- Nieautoryzowany dostÄ™p do danych.
- MoÅ¼liwoÅ›Ä‡ usuniÄ™cia, modyfikacji lub odczytania poufnych danych.
- Potencjalne przejÄ™cie kontroli nad bazÄ… danych.

---

### Zalecenia
1. **UÅ¼ycie zapytaÅ„ z parametrami (Prepared Statements)**:
   ```java
   @Repository
   public interface UserRepository extends JpaRepository<User, Long> {

       @Query("SELECT u FROM User u WHERE u.username = :username")
       List<User> findByUsername(@Param("username") String username);
   }
   ```

   **Dlaczego bezpieczne?**  
   - W Spring Data JPA parametry w zapytaniach sÄ… automatycznie escapowane, co zapobiega wstrzykniÄ™ciom SQL.

2. **Korzystanie z metod zapytaÅ„ Spring Data JPA**:
   ```java
   @Repository
   public interface UserRepository extends JpaRepository<User, Long> {

       // Metoda zapytania generowana automatycznie na podstawie nazwy metody
       List<User> findByUsername(String username);
   }
   ```

   **Dlaczego bezpieczne?**  
   - Spring Data JPA automatycznie generuje zapytania SQL z uÅ¼yciem parametrÃ³w, eliminujÄ…c ryzyko SQL Injection.

---

### Mechanizmy Spring Security
1. **Walidacja danych wejÅ›ciowych**:
   - UÅ¼ywaj adnotacji takich jak `@Pattern` lub `@Size` do walidacji danych wejÅ›ciowych:
     ```java
     @RestController
     public class UserController {

         @GetMapping("/users")
         public List<User> getUsers(@RequestParam @Pattern(regexp = "^[a-zA-Z0-9]*$") String username) {
             return userRepository.findByUsername(username);
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Walidacja ogranicza dane wejÅ›ciowe do akceptowalnych wartoÅ›ci.

2. **Monitorowanie i rejestrowanie aktywnoÅ›ci bazy danych**:
   - UÅ¼ycie mechanizmÃ³w monitorowania zapytaÅ„, takich jak Hibernate Envers lub logi bazy danych, aby wykryÄ‡ nietypowe wzorce zapytaÅ„.

3. **UÅ¼ycie ORM (Object-Relational Mapping)**:
   - Korzystaj z JPA i Hibernate zamiast natywnych zapytaÅ„ SQL. ORM zapewnia domyÅ›lne zabezpieczenia przed SQL Injection.

</details>

## A04:2021 Insecure Design

<details>
<summary>ğŸ”´ 1. Open Redirect</summary>

### Opis
Open Redirect to podatnoÅ›Ä‡, ktÃ³ra pozwala atakujÄ…cemu na przekierowanie uÅ¼ytkownika na zewnÄ™trznÄ…, zÅ‚oÅ›liwÄ… stronÄ™ internetowÄ…. W Springu problem ten moÅ¼e wystÄ…piÄ‡, jeÅ›li aplikacja uÅ¼ywa przekierowaÅ„ na podstawie danych wejÅ›ciowych uÅ¼ytkownika bez odpowiedniej walidacji lub ograniczeÅ„.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class RedirectController {

    @GetMapping("/redirect")
    public ResponseEntity<Void> redirect(@RequestParam String url) {
        // Niebezpieczne przekierowanie na adres URL dostarczony przez uÅ¼ytkownika
        return ResponseEntity.status(HttpStatus.FOUND)
                .location(URI.create(url))
                .build();
    }
}
```

**Dlaczego podatny?**  
- UÅ¼ytkownik moÅ¼e dostarczyÄ‡ zÅ‚oÅ›liwy adres URL, np. `http://malicious-site.com`, ktÃ³ry zostanie uÅ¼yty do przekierowania ofiary.
- Aplikacja nie weryfikuje, czy adres URL jest zaufany.

---

### Skutki
- Przekierowanie uÅ¼ytkownika na zÅ‚oÅ›liwe strony internetowe.
- KradzieÅ¼ danych uwierzytelniajÄ…cych (phishing).

---

### Zalecenia
1. **Ograniczenie przekierowaÅ„ do zaufanych domen**:
   ```java
   @RestController
   public class RedirectController {

       private static final List<String> TRUSTED_DOMAINS = List.of("example.com", "trusted.com");

       @GetMapping("/redirect")
       public ResponseEntity<Void> redirect(@RequestParam String url) {
           URI uri = URI.create(url);

           // Weryfikacja, czy domena jest zaufana
           if (TRUSTED_DOMAINS.stream().noneMatch(uri.getHost()::endsWith)) {
               return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
           }

           return ResponseEntity.status(HttpStatus.FOUND)
                   .location(uri)
                   .build();
       }
   }
   ```

   **Dlaczego bezpieczne?**  
   - Przekierowanie odbywa siÄ™ tylko do zaufanych domen.
   - Blokuje moÅ¼liwoÅ›Ä‡ uÅ¼ycia niezaufanych adresÃ³w URL.

---

### Mechanizmy Spring Security
1. **WÅ‚Ä…czenie nagÅ‚Ã³wkÃ³w zabezpieczajÄ…cych przekierowania**:
   - Spring Security automatycznie ustawia nagÅ‚Ã³wki takie jak `X-Content-Type-Options` i `X-Frame-Options`, ktÃ³re mogÄ… pomÃ³c w ochronie przed zÅ‚oÅ›liwymi przekierowaniami.

2. **Filtrowanie danych wejÅ›ciowych**:
   - MoÅ¼na zastosowaÄ‡ adnotacje `@Valid` oraz `@Pattern`, aby ograniczyÄ‡ potencjalnie zÅ‚oÅ›liwe dane wejÅ›ciowe.


</details>

<details>
<summary>ğŸ”´ 2. Login Rate Limiting</summary>

### Opis
Brak mechanizmu ograniczania liczby Å¼Ä…daÅ„ (rate limiting) w aplikacji moÅ¼e prowadziÄ‡ do atakÃ³w typu brute force lub denial of service (DoS). W Spring REST API problem ten wystÄ™puje, gdy aplikacja nie weryfikuje, ile Å¼Ä…daÅ„ logowania pochodzi od konkretnego klienta w okreÅ›lonym czasie.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class LoginController {

    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestParam String username, @RequestParam String password) {
        // Brak ograniczenia liczby prÃ³b logowania
        boolean success = authenticate(username, password);
        return success ? ResponseEntity.ok("Login successful") : ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
    }

    private boolean authenticate(String username, String password) {
        // Prosta weryfikacja logowania
        return "user".equals(username) && "password".equals(password);
    }
}
```

**Dlaczego podatny?**  
- AtakujÄ…cy moÅ¼e wysyÅ‚aÄ‡ nieograniczonÄ… liczbÄ™ Å¼Ä…daÅ„ logowania, prÃ³bujÄ…c odgadnÄ…Ä‡ dane uwierzytelniajÄ…ce.
- Brak jakichkolwiek mechanizmÃ³w rate limiting pozwala na wykorzystanie zasobÃ³w serwera, co moÅ¼e prowadziÄ‡ do ataku DoS.

---

### Skutki
- MoÅ¼liwoÅ›Ä‡ przeprowadzenia skutecznych atakÃ³w brute force.
- ObciÄ…Å¼enie serwera i ograniczenie dostÄ™pnoÅ›ci usÅ‚ugi (atak DoS).
- Naruszenie bezpieczeÅ„stwa uÅ¼ytkownikÃ³w.

---

### Zalecenia
1. **Wprowadzenie limitu liczby Å¼Ä…daÅ„ (Rate Limiting)**:
   - UÅ¼yj biblioteki takiej jak Bucket4j, aby ograniczyÄ‡ liczbÄ™ Å¼Ä…daÅ„:
     ```java
     @RestController
     public class LoginController {

         private final Bucket bucket = Bucket4j.builder()
                 .addLimit(Bandwidth.simple(5, Duration.ofMinutes(1))) // 5 Å¼Ä…daÅ„ na minutÄ™
                 .build();

         @PostMapping("/login")
         public ResponseEntity<String> login(@RequestParam String username, @RequestParam String password) {
             if (!bucket.tryConsume(1)) {
                 return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body("Too many login attempts. Please try again later.");
             }

             boolean success = authenticate(username, password);
             return success ? ResponseEntity.ok("Login successful") : ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
         }

         private boolean authenticate(String username, String password) {
             return "user".equals(username) && "password".equals(password);
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Mechanizm Bucket4j ogranicza liczbÄ™ Å¼Ä…daÅ„ w okreÅ›lonym czasie, chroniÄ…c przed brute force i DoS.

2. **Blokowanie uÅ¼ytkownikÃ³w po okreÅ›lonej liczbie nieudanych prÃ³b**:
   - Dodaj funkcjonalnoÅ›Ä‡ blokady konta po okreÅ›lonej liczbie nieudanych prÃ³b logowania:
     ```java
     @Service
     public class LoginAttemptService {

         private final Map<String, Integer> loginAttempts = new ConcurrentHashMap<>();
         private static final int MAX_ATTEMPTS = 5;

         public void loginFailed(String username) {
             loginAttempts.put(username, loginAttempts.getOrDefault(username, 0) + 1);
         }

         public boolean isBlocked(String username) {
             return loginAttempts.getOrDefault(username, 0) >= MAX_ATTEMPTS;
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Zapobiega nieograniczonej liczbie prÃ³b logowania, blokujÄ…c uÅ¼ytkownikÃ³w po okreÅ›lonej liczbie nieudanych prÃ³b.

3. **Dodanie reCAPTCHA do procesu logowania**:
   - Po okreÅ›lonej liczbie prÃ³b logowania dodaj weryfikacjÄ™ CAPTCHA.


---

### Mechanizmy Spring Security
1. **Rate limiting przy uÅ¼yciu SecurityFilterChain**:
   - MoÅ¼esz dodaÄ‡ filtr ograniczajÄ…cy liczbÄ™ Å¼Ä…daÅ„:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http
                 .addFilterBefore(new RateLimitingFilter(), UsernamePasswordAuthenticationFilter.class);
             return http.build();
         }
     }

     public class RateLimitingFilter extends GenericFilterBean {

         private final Bucket bucket = Bucket4j.builder()
                 .addLimit(Bandwidth.simple(5, Duration.ofMinutes(1))) // 5 Å¼Ä…daÅ„ na minutÄ™
                 .build();

         @Override
         public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
             if (!bucket.tryConsume(1)) {
                 ((HttpServletResponse) response).setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
                 return;
             }
             chain.doFilter(request, response);
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Filtr ogranicza liczbÄ™ Å¼Ä…daÅ„ na poziomie warstwy zabezpieczeÅ„ Spring Security.


</details>
