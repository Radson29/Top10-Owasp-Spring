
# OWASP Top 10 (2021) - Spring Framework

## A01:2021 Broken Access Control

<details>
<summary> ğŸ”´ 1. Local File Inclusion, LFI</summary>

### Opis
Local File Inclusion (LFI) to podatnoÅ›Ä‡ umoÅ¼liwiajÄ…ca nieautoryzowany dostÄ™p do lokalnych plikÃ³w na serwerze. W Springu moÅ¼e wystÄ…piÄ‡, gdy dane wejÅ›ciowe uÅ¼ytkownika sÄ… przekazywane bez walidacji jako Å›cieÅ¼ka do pliku i uÅ¼ywane do dynamicznego Å‚adowania zasobÃ³w za pomocÄ… klas takich jak `Files` czy `Paths`.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@GetMapping("/loadFile")
public ResponseEntity<String> loadFile(@RequestParam String filePath) throws IOException {
    // UÅ¼ytkownik moÅ¼e dostarczyÄ‡ dowolnÄ… Å›cieÅ¼kÄ™, np. "../etc/passwd"
    Path path = Paths.get(filePath);
    String content = Files.readString(path); // Brak weryfikacji, czy Å›cieÅ¼ka jest bezpieczna
    return ResponseEntity.ok(content);
}
```

**Dlaczego podatny?**  
- Spring umoÅ¼liwia dynamiczne przetwarzanie parametrÃ³w Å¼Ä…dania (np. `@RequestParam`), co przy braku walidacji pozwala na manipulacjÄ™ Å›cieÅ¼kami i dostÄ™p do nieautoryzowanych plikÃ³w.

---

### Skutki
- MoÅ¼liwoÅ›Ä‡ odczytu plikÃ³w systemowych (np. `/etc/passwd`).
- Ujawnienie wraÅ¼liwych informacji, takich jak hasÅ‚a lub klucze.

---

### Zalecenia
```java
@GetMapping("/loadFile")
public ResponseEntity<String> loadFile(@RequestParam String fileName) throws IOException {
    // Definiujemy bezpieczny katalog
    Path safeDirectory = Paths.get("safeDir").toAbsolutePath();
    // Tworzymy Å›cieÅ¼kÄ™ dla pliku i normalizujemy jÄ…
    Path filePath = safeDirectory.resolve(fileName).normalize();

    // Weryfikujemy, czy plik znajduje siÄ™ w dozwolonym katalogu
    if (!filePath.startsWith(safeDirectory)) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Access denied");
    }

    String content = Files.readString(filePath);
    return ResponseEntity.ok(content);
}
```

**Dlaczego bezpieczny?**  
- Ogranicza dostÄ™p do katalogu `safeDir`.
- UÅ¼ywa `normalize`, aby zapobiec manipulacji Å›cieÅ¼kami typu `../`.

---

### Mechanizmy Spring Security
1. **Ograniczenie dostÄ™pu do zasobÃ³w**:
   ```java
   @Configuration
   @EnableWebSecurity
   public class SecurityConfig extends WebSecurityConfigurerAdapter {
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           // Ustawiamy reguÅ‚y dostÄ™pu:
           // - dostÄ™p do Å›cieÅ¼ek w katalogu "safeDir" jest dozwolony
           // - pozostaÅ‚e Å›cieÅ¼ki sÄ… blokowane
           http.authorizeRequests()
               .antMatchers("/safeDir/**").permitAll() // Dozwolone tylko "safeDir"
               .anyRequest().denyAll(); // Wszystko inne jest blokowane
       }
   }
   ```
   **Dlaczego bezpieczny?**  
   - ReguÅ‚y Spring Security kontrolujÄ… dostÄ™p do endpointÃ³w, ograniczajÄ…c dostÄ™p do katalogÃ³w.

</details>

<details>
<summary> ğŸ”´ 2. Object access middleware</summary>

### Opis
PodatnoÅ›ci w Springu zwiÄ…zane z dostÄ™pem do obiektÃ³w mogÄ… wystÄ…piÄ‡, gdy brak jest walidacji danych uÅ¼ytkownika lub kontroli dostÄ™pu. PrzykÅ‚adowo, brak weryfikacji uÅ¼ytkownika przy pobieraniu danych za pomocÄ… metod serwisowych moÅ¼e prowadziÄ‡ do eskalacji uprawnieÅ„.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@GetMapping("/getUserData")
public ResponseEntity<UserData> getUserData(@RequestParam Long userId) {
    // Metoda pobiera dane dowolnego uÅ¼ytkownika bez sprawdzania uprawnieÅ„
    UserData userData = userService.findById(userId); 
    return ResponseEntity.ok(userData);
}
```

**Dlaczego podatny?**  
- Brak weryfikacji, czy zalogowany uÅ¼ytkownik jest wÅ‚aÅ›cicielem danych, ktÃ³re chce uzyskaÄ‡.
- Spring umoÅ¼liwia Å‚atwe mapowanie parametrÃ³w (np. `@RequestParam`), ale to programista odpowiada za kontrolÄ™ dostÄ™pu.

---

### Skutki
- Nieautoryzowany dostÄ™p do danych innego uÅ¼ytkownika.
- Naruszenie poufnoÅ›ci danych.

---

### Zalecenia
```java
@GetMapping("/getUserData")
public ResponseEntity<UserData> getUserData(@RequestParam Long userId, Principal principal) {
    // Pobieramy nazwÄ™ uÅ¼ytkownika z kontekstu bezpieczeÅ„stwa
    String currentUsername = principal.getName();
    UserData userData = userService.findById(userId);

    // Sprawdzamy, czy zalogowany uÅ¼ytkownik ma dostÄ™p do danych
    if (!userData.getUsername().equals(currentUsername)) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(null);
    }

    return ResponseEntity.ok(userData);
}
```

**Dlaczego bezpieczny?**  
- Sprawdza, czy dane naleÅ¼Ä… do uÅ¼ytkownika wysyÅ‚ajÄ…cego Å¼Ä…danie.

---

### Mechanizmy Spring Security
1. **Weryfikacja uprawnieÅ„ za pomocÄ… adnotacji**:
   ```java
   @Service
   public class UserService {
       // Adnotacja @PreAuthorize sprawdza, czy ID uÅ¼ytkownika pasuje do ID z kontekstu
       @PreAuthorize("#userId == authentication.principal.id")
       public UserData getUserData(Long userId) {
           return userRepository.findById(userId)
               .orElseThrow(() -> new RuntimeException("User not found"));
       }
   }
   ```
   **Dlaczego bezpieczny?**  
   - Adnotacja `@PreAuthorize` weryfikuje uprawnienia przed wykonaniem metody.

</details>

<details>
<summary>3. Mass Assignment</summary>

### Opis
Mass Assignment w Springu moÅ¼e wystÄ…piÄ‡, gdy dane wejÅ›ciowe sÄ… mapowane bezpoÅ›rednio na obiekt modelu (np. `@RequestBody`). PrzykÅ‚adowo, uÅ¼ytkownik moÅ¼e manipulowaÄ‡ przesyÅ‚anymi danymi, aby zmieniÄ‡ pola, do ktÃ³rych nie powinien mieÄ‡ dostÄ™pu.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@PostMapping("/updateUser")
public ResponseEntity<String> updateUser(@RequestBody User user) {
    // BezpoÅ›rednie przypisanie danych uÅ¼ytkownika z Å¼Ä…dania do modelu
    userRepository.save(user); // Brak kontroli nad modyfikowanymi polami
    return ResponseEntity.ok("User updated");
}
```

**Dlaczego podatny?**  
- Spring automatycznie mapuje dane JSON na obiekt, co pozwala na nieautoryzowane zmiany, np. ustawienie pola `role`.

---

### Skutki
- Nieautoryzowane modyfikacje wraÅ¼liwych pÃ³l, takich jak role uÅ¼ytkownika.
- MoÅ¼liwoÅ›Ä‡ eskalacji uprawnieÅ„.

---

### Zalecenia
```java
@PostMapping("/updateUser")
public ResponseEntity<String> updateUser(@RequestBody UserDto userDto, Principal principal) {
    // Pobieramy dane zalogowanego uÅ¼ytkownika
    User currentUser = userRepository.findByUsername(principal.getName());

    // RÄ™czne przypisanie tylko wybranych pÃ³l
    currentUser.setName(userDto.getName());
    currentUser.setEmail(userDto.getEmail());

    userRepository.save(currentUser);
    return ResponseEntity.ok("User updated");
}
```

**Dlaczego bezpieczny?**  
- Wykorzystuje DTO do ograniczenia modyfikowanych pÃ³l.
- Zapewnia peÅ‚nÄ… kontrolÄ™ nad procesem aktualizacji.

---

### Mechanizmy Spring Security
1. **Walidacja danych wejÅ›ciowych za pomocÄ… DTO**:
   ```java
   public class UserDto {
       @NotBlank
       private String name;

       @Email
       private String email;
   }
   ```

2. **Bezpieczne mapowanie danych w kontrolerze**:
   ```java
   @PostMapping("/updateUser")
   public ResponseEntity<String> updateUser(@Valid @RequestBody UserDto userDto) {
       // Tylko dane zgodne z DTO zostanÄ… zaakceptowane
       return ResponseEntity.ok("User updated");
   }
   ```

</details>

<details>
<summary>ğŸ”´ 4. Insecure Direct Object Reference (IDOR)</summary>

### Opis
Insecure Direct Object Reference (IDOR) to podatnoÅ›Ä‡, ktÃ³ra wystÄ™puje, gdy aplikacja pozwala uÅ¼ytkownikowi na bezpoÅ›redni dostÄ™p do zasobÃ³w (np. rekordÃ³w w bazie danych) za pomocÄ… identyfikatorÃ³w, takich jak ID. W Springu podatnoÅ›Ä‡ ta moÅ¼e wystÄ…piÄ‡, jeÅ›li parametry takie jak `@RequestParam` czy `@PathVariable` nie sÄ… odpowiednio weryfikowane w kontekÅ›cie dostÄ™pu uÅ¼ytkownika do danego zasobu.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@GetMapping("/documents/{docId}")
public ResponseEntity<Document> getDocument(@PathVariable Long docId) {
    // Pobieramy dokument z bazy danych na podstawie ID przekazanego w Å¼Ä…daniu
    Document document = documentRepository.findById(docId)
            .orElseThrow(() -> new RuntimeException("Document not found"));
    return ResponseEntity.ok(document);
}
```

**Dlaczego podatny?**  
- UÅ¼ytkownik moÅ¼e manipulowaÄ‡ parametrem `docId` w Å¼Ä…daniu, aby uzyskaÄ‡ dostÄ™p do dokumentÃ³w, do ktÃ³rych nie powinien mieÄ‡ dostÄ™pu.
- Brak weryfikacji, czy zalogowany uÅ¼ytkownik ma uprawnienia do danego zasobu.

---

### Skutki
- Nieautoryzowany dostÄ™p do danych innych uÅ¼ytkownikÃ³w.
- Ujawnienie poufnych informacji, takich jak dokumenty, dane osobowe czy transakcje.

---

### Zalecenia
```java
@GetMapping("/documents/{docId}")
public ResponseEntity<Document> getDocument(@PathVariable Long docId, Principal principal) {
    // Pobieramy nazwÄ™ uÅ¼ytkownika z kontekstu bezpieczeÅ„stwa
    String currentUsername = principal.getName();

    // Pobieramy dokument z bazy danych
    Document document = documentRepository.findById(docId)
            .orElseThrow(() -> new RuntimeException("Document not found"));

    // Sprawdzamy, czy dokument naleÅ¼y do zalogowanego uÅ¼ytkownika
    if (!document.getOwner().equals(currentUsername)) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(null);
    }

    return ResponseEntity.ok(document);
}
```

**Dlaczego bezpieczny?**  
- Weryfikuje, czy dokument naleÅ¼y do zalogowanego uÅ¼ytkownika.
- Ogranicza dostÄ™p do zasobÃ³w na podstawie toÅ¼samoÅ›ci uÅ¼ytkownika.

---

### Mechanizmy Spring Security
1. **Kontrola dostÄ™pu z uÅ¼yciem `@PreAuthorize`**:
   ```java
   @Service
   public class DocumentService {
       // Adnotacja weryfikuje, czy uÅ¼ytkownik jest wÅ‚aÅ›cicielem dokumentu przed wykonaniem metody
       @PreAuthorize("@documentSecurityService.isOwner(#docId, authentication.name)")
       public Document getDocument(Long docId) {
           return documentRepository.findById(docId)
                   .orElseThrow(() -> new RuntimeException("Document not found"));
       }
   }

   @Component
   public class DocumentSecurityService {
       public boolean isOwner(Long docId, String username) {
           Document document = documentRepository.findById(docId).orElse(null);
           return document != null && document.getOwner().equals(username);
       }
   }
   ```

   **Dlaczego bezpieczny?**  
   - Adnotacja `@PreAuthorize` wymusza weryfikacjÄ™ uprawnieÅ„ przed wykonaniem metody.
   - Logika w klasie `DocumentSecurityService` dokÅ‚adnie sprawdza, czy uÅ¼ytkownik jest wÅ‚aÅ›cicielem zasobu.

2. **Definiowanie rÃ³l i reguÅ‚ dostÄ™pu**:
   ```java
   @Override
   protected void configure(HttpSecurity http) throws Exception {
       http.authorizeRequests()
           .antMatchers("/documents/**").authenticated() // DostÄ™p do dokumentÃ³w tylko dla zalogowanych uÅ¼ytkownikÃ³w
           .anyRequest().denyAll();
   }
   ```

   **Dlaczego bezpieczny?**  
   - Ogranicza dostÄ™p do endpointÃ³w tylko dla uwierzytelnionych uÅ¼ytkownikÃ³w.
   - Blokuje nieautoryzowany dostÄ™p do wszystkich innych zasobÃ³w.

</details>

## A02:2021 Cryptographic Failures

<details>
<summary>ğŸ”´ 1. Weak Encoding for Password</summary>

### Opis
PodatnoÅ›Ä‡ zwiÄ…zana z niewÅ‚aÅ›ciwym hashowaniem haseÅ‚ wystÄ™puje, gdy aplikacja uÅ¼ywa sÅ‚abych funkcji hashujÄ…cych, takich jak MD5 lub SHA-1, ktÃ³re sÄ… podatne na ataki siÅ‚owe (brute force) lub kolizje. W Springu ta podatnoÅ›Ä‡ moÅ¼e wystÄ…piÄ‡, jeÅ›li implementacja przechowywania haseÅ‚ nie wykorzystuje odpowiednich algorytmÃ³w, takich jak BCrypt.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@Service
public class UserService {

    // Hashowanie hasÅ‚a za pomocÄ… MD5 (sÅ‚aby algorytm)
    public String hashPassword(String password) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] hash = md.digest(password.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Error hashing password", e);
        }
    }
}
```

**Dlaczego podatny?**  
- MD5 jest przestarzaÅ‚ym algorytmem hashujÄ…cym, podatnym na ataki brute force i kolizje.
- Brak mechanizmu saltingu, co zwiÄ™ksza ryzyko zÅ‚amania haseÅ‚.

---

### Skutki
- Nieautoryzowany dostÄ™p do kont uÅ¼ytkownikÃ³w w przypadku zÅ‚amania haseÅ‚.
- Naruszenie poufnoÅ›ci danych.

---

### Zalecenia
```java
@Service
public class UserService {

    // Hashowanie hasÅ‚a za pomocÄ… BCrypt
    public String hashPassword(String password) {
        return new BCryptPasswordEncoder().encode(password);
    }
}
```

**Dlaczego bezpieczny?**  
- BCrypt zostaÅ‚ zaprojektowany specjalnie do przechowywania haseÅ‚, zapewniajÄ…c wbudowany mechanizm saltingu.
- Jego mechanizm adaptacyjny zwiÄ™ksza czas hashowania w miarÄ™ wzrostu mocy obliczeniowej atakujÄ…cych.

---

### Mechanizmy Spring Security
1. **UÅ¼ycie wbudowanego `PasswordEncoder`**:
   ```java
   @Configuration
   public class SecurityConfig {
       @Bean
       public PasswordEncoder passwordEncoder() {
           // Konfigurujemy BCryptPasswordEncoder jako domyÅ›lny mechanizm hashowania
           return new BCryptPasswordEncoder();
       }
   }
   ```

   **Dlaczego bezpieczny?**  
   - Spring Security rekomenduje uÅ¼ycie `BCryptPasswordEncoder`, ktÃ³ry jest zgodny z najlepszymi praktykami dotyczÄ…cymi przechowywania haseÅ‚.

2. **Weryfikacja hasÅ‚a**:
   ```java
   @Service
   public class AuthenticationService {
       @Autowired
       private PasswordEncoder passwordEncoder;

       public boolean verifyPassword(String rawPassword, String hashedPassword) {
           // Sprawdzanie hasÅ‚a za pomocÄ… BCrypt
           return passwordEncoder.matches(rawPassword, hashedPassword);
       }
   }
   ```

   **Dlaczego bezpieczny?**  
   - Funkcja `matches` zapewnia poprawne porÃ³wnanie hasÅ‚a w formie jawnej z jego wersjÄ… zahashowanÄ….

</details>

<details>
<summary> ğŸ”´ 2. Use of Hard-coded Cryptographic Key</summary>

### Opis
PodatnoÅ›Ä‡ zwiÄ…zana z uÅ¼ywaniem zaszytych na staÅ‚e (hard-coded) kluczy kryptograficznych wystÄ™puje, gdy aplikacja przechowuje klucz szyfrujÄ…cy bezpoÅ›rednio w kodzie ÅºrÃ³dÅ‚owym. MoÅ¼e to prowadziÄ‡ do ujawnienia klucza i umoÅ¼liwienia atakujÄ…cym odszyfrowania poufnych danych. W Springu problem ten moÅ¼e wystÄ…piÄ‡, gdy klucz jest zapisany w zmiennej w kodzie lub w plikach konfiguracyjnych bez odpowiedniego zabezpieczenia.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@Service
public class EncryptionService {

    // Zaszyty na staÅ‚e klucz kryptograficzny (podatny)
    private static final String SECRET_KEY = "hardcoded_key_12345";

    public String encrypt(String data) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        SecretKeySpec key = new SecretKeySpec(SECRET_KEY.getBytes(), "AES");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes()));
    }
}
```

**Dlaczego podatny?**  
- Klucz kryptograficzny jest zapisany w kodzie i moÅ¼e byÄ‡ Å‚atwo odczytany przez atakujÄ…cych.

---

### Skutki
- MoÅ¼liwoÅ›Ä‡ odszyfrowania poufnych danych przez osoby trzecie.
- Naruszenie poufnoÅ›ci danych uÅ¼ytkownikÃ³w.

---

### Zalecenia
```java
@Service
public class EncryptionService {

    // Klucz kryptograficzny jest przechowywany w bezpiecznym magazynie, np. w pliku konfiguracyjnym lub systemie zarzÄ…dzania sekretami
    @Value("${encryption.secret-key}")
    private String secretKey;

    public String encrypt(String data) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        SecretKeySpec key = new SecretKeySpec(secretKey.getBytes(), "AES");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes()));
    }
}
```

**Dlaczego bezpieczny?**  
- Klucz kryptograficzny jest przechowywany poza kodem ÅºrÃ³dÅ‚owym, np. w `application.properties` lub w systemie zarzÄ…dzania sekretami (Vault, AWS Secrets Manager).
- DostÄ™p do klucza jest ograniczony odpowiednimi mechanizmami uprawnieÅ„.

---

### Mechanizmy Spring Security
1. **Przechowywanie klucza w pliku konfiguracyjnym**:
   ```properties
   # application.properties
   encryption.secret-key=secure_random_generated_key
   ```

   **Dlaczego bezpieczne?**  
   - Plik konfiguracyjny moÅ¼e byÄ‡ chroniony odpowiednimi uprawnieniami dostÄ™pu do systemu operacyjnego.
   - Klucz nie jest zaszyty w kodzie, co utrudnia jego wyciek.

2. **UÅ¼ycie systemu zarzÄ…dzania sekretami**:
   - Integracja z narzÄ™dziami takimi jak HashiCorp Vault, AWS Secrets Manager czy Azure Key Vault.
   - PrzykÅ‚ad pobierania klucza z Vault:
     ```java
     @Service
     public class EncryptionService {

         @Autowired
         private VaultTemplate vaultTemplate;

         public String getSecretKey() {
             return vaultTemplate.read("secret/encryption").getData().get("key");
         }
     }
     ```

   **Dlaczego bezpieczne?**  
   - Klucz jest przechowywany w dedykowanym, bezpiecznym magazynie, a dostÄ™p do niego wymaga odpowiednich uprawnieÅ„.

</details>
<details>
<summary>ğŸ”´ 3. Cleartext Transmission of Sensitive Information</summary>

### Opis
PodatnoÅ›Ä‡ ta wystÄ™puje, gdy aplikacja przesyÅ‚a poufne informacje (np. dane logowania, dane osobowe, czy numery kart kredytowych) w formie jawnego tekstu (cleartext), bez odpowiedniego zabezpieczenia protokoÅ‚em szyfrowania, takim jak HTTPS. W Springu problem ten moÅ¼e wystÄ…piÄ‡, jeÅ›li endpointy sÄ… wystawione na HTTP zamiast HTTPS lub jeÅ›li wraÅ¼liwe dane sÄ… przesyÅ‚ane jako jawny tekst w odpowiedziach lub nagÅ‚Ã³wkach HTTP.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class LoginController {

    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestBody LoginRequest loginRequest) {
        // WraÅ¼liwe dane uÅ¼ytkownika sÄ… zwracane w jawny sposÃ³b
        return ResponseEntity.ok("User logged in with password: " + loginRequest.getPassword());
    }
}
```

**Dlaczego podatny?**  
- Endpoint `/login` jest dostÄ™pny przez HTTP, co umoÅ¼liwia przechwycenie danych podczas transmisji (np. za pomocÄ… ataku typu Man-in-the-Middle).
- HasÅ‚o uÅ¼ytkownika jest przesyÅ‚ane jako czÄ™Å›Ä‡ odpowiedzi w jawny sposÃ³b.

---

### Skutki
- PrzejÄ™cie poufnych danych uÅ¼ytkownika, takich jak login i hasÅ‚o.
- MoÅ¼liwoÅ›Ä‡ nieautoryzowanego dostÄ™pu do systemu.

---

### Zalecenia
```java
@RestController
public class LoginController {

    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestBody LoginRequest loginRequest) {
        // Minimalizujemy wraÅ¼liwe dane w odpowiedzi
        return ResponseEntity.ok("User logged in successfully.");
    }
}
```

**Dlaczego bezpieczny?**  
- WraÅ¼liwe informacje, takie jak hasÅ‚o, nie sÄ… przesyÅ‚ane w odpowiedzi.
- Dane sÄ… przesyÅ‚ane wyÅ‚Ä…cznie przez HTTPS, co zabezpiecza je przed przechwyceniem.

---

### Mechanizmy Spring Security
1. **Wymuszanie HTTPS**:
   - MoÅ¼na skonfigurowaÄ‡ aplikacjÄ™ Spring do wymuszania HTTPS, dodajÄ…c poniÅ¼szÄ… konfiguracjÄ™:
   ```java
   @Configuration
   public class SecurityConfig extends WebSecurityConfigurerAdapter {

       @Override
       protected void configure(HttpSecurity http) throws Exception {
           http.requiresChannel()
               .anyRequest()
               .requiresSecure(); // Wymusza HTTPS dla wszystkich Å¼Ä…daÅ„
       }
   }
   ```

   **Dlaczego bezpieczne?**  
   - Spring Security automatycznie przekierowuje wszystkie Å¼Ä…dania HTTP na HTTPS.

2. **Dodanie certyfikatu SSL w `application.properties`**:
   ```properties
   server.ssl.key-store=classpath:keystore.p12
   server.ssl.key-store-password=yourPassword
   server.ssl.key-store-type=PKCS12
   server.port=8443
   ```

   **Dlaczego bezpieczne?**  
   - Dane sÄ… szyfrowane podczas transmisji przy uÅ¼yciu protokoÅ‚u HTTPS z certyfikatem SSL/TLS.
</details>

## A03:2021 Injection

<details>
<summary>ğŸ”´ 1. Remote Code Execution (RCE)</summary>

### Opis
Remote Code Execution (RCE) to podatnoÅ›Ä‡, ktÃ³ra pozwala atakujÄ…cemu na wstrzykniÄ™cie i wykonanie dowolnego kodu na serwerze. W Springu ta podatnoÅ›Ä‡ moÅ¼e wystÄ…piÄ‡ w dwÃ³ch gÅ‚Ã³wnych kontekstach:
1. **Spring Expression Language (SpEL):** JeÅ›li uÅ¼ytkownik ma kontrolÄ™ nad wyraÅ¼eniami SpEL i sÄ… one wykonywane bez ograniczeÅ„.
2. **Deserializacja obiektÃ³w:** Gdy aplikacja deserializuje niezaufane dane bez odpowiedniej walidacji.

---

### PrzykÅ‚ad podatnoÅ›ci: SpEL
```java
@RestController
public class SpELController {

    @PostMapping("/evaluate")
    public ResponseEntity<String> evaluateExpression(@RequestParam String expression) {
        // Wykonanie wyraÅ¼enia SpEL dostarczonego przez uÅ¼ytkownika
        ExpressionParser parser = new SpelExpressionParser();
        Expression exp = parser.parseExpression(expression);
        String result = exp.getValue().toString();
        return ResponseEntity.ok("Result: " + result);
    }
}
```

**Dlaczego podatny?**  
- UÅ¼ytkownik moÅ¼e wstrzyknÄ…Ä‡ zÅ‚oÅ›liwe wyraÅ¼enie SpEL, takie jak `T(java.lang.Runtime).getRuntime().exec("rm -rf /")`, co pozwoli na wykonanie dowolnego polecenia systemowego.

---

### PrzykÅ‚ad podatnoÅ›ci: Deserializacja obiektÃ³w
```java
@RestController
public class DeserializationController {

    @PostMapping("/deserialize")
    public ResponseEntity<Object> deserialize(@RequestBody byte[] data) throws IOException, ClassNotFoundException {
        // Deserializacja danych dostarczonych przez uÅ¼ytkownika
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));
        Object obj = ois.readObject();
        return ResponseEntity.ok(obj);
    }
}
```

**Dlaczego podatny?**  
- Deserializacja niezaufanych danych umoÅ¼liwia atakujÄ…cemu dostarczenie zÅ‚oÅ›liwego obiektu, ktÃ³ry moÅ¼e wykonaÄ‡ niebezpieczne operacje, takie jak otwieranie poÅ‚Ä…czeÅ„ sieciowych lub modyfikacja plikÃ³w.

---

### Skutki
- Wykonanie dowolnego kodu na serwerze.
- PrzejÄ™cie kontroli nad aplikacjÄ… lub serwerem.
- Utrata poufnoÅ›ci, integralnoÅ›ci lub dostÄ™pnoÅ›ci danych.

---

### Zalecenia: SpEL
```java
@RestController
public class SpELController {

    @PostMapping("/evaluate")
    public ResponseEntity<String> evaluateExpression(@RequestParam String expression) {
        // Ograniczenie wyraÅ¼eÅ„ SpEL do prostych operacji matematycznych
        if (!expression.matches("[0-9+\-*/()]*")) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Invalid expression");
        }

        ExpressionParser parser = new SpelExpressionParser();
        Expression exp = parser.parseExpression(expression);
        String result = exp.getValue().toString();
        return ResponseEntity.ok("Result: " + result);
    }
}
```

**Dlaczego bezpieczny?**  
- Ogranicza dopuszczalne wyraÅ¼enia do prostych operacji matematycznych.
- Nie pozwala na wykonanie potencjalnie niebezpiecznych wyraÅ¼eÅ„ SpEL.

---

### Zalecenia: Deserializacja
```java
@RestController
public class DeserializationController {

    @PostMapping("/deserialize")
    public ResponseEntity<Object> deserialize(@RequestBody byte[] data) throws IOException, ClassNotFoundException {
        // Zastosowanie biaÅ‚ej listy dozwolonych klas
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data)) {
            @Override
            protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
                if (!"com.example.SafeClass".equals(desc.getName())) {
                    throw new InvalidClassException("Unauthorized deserialization attempt: " + desc.getName());
                }
                return super.resolveClass(desc);
            }
        };

        Object obj = ois.readObject();
        return ResponseEntity.ok(obj);
    }
}
```

**Dlaczego bezpieczny?**  
- Implementuje biaÅ‚Ä… listÄ™ klas, ktÃ³re mogÄ… byÄ‡ deserializowane.
- UniemoÅ¼liwia wykonanie zÅ‚oÅ›liwych obiektÃ³w dostarczonych przez atakujÄ…cego.

---

### Mechanizmy Spring Security
1. **WyÅ‚Ä…cz SpEL w miejscach, gdzie jest to moÅ¼liwe**:
   - JeÅ›li SpEL nie jest konieczne, ogranicz jego uÅ¼ycie w konfiguracji Springa lub uÅ¼yj bardziej ograniczonych wyraÅ¼eÅ„.

2. **Walidacja danych wejÅ›ciowych**:
   - Weryfikuj i waliduj dane wejÅ›ciowe uÅ¼ytkownika przed ich przetwarzaniem.
   ```java
   @PostMapping("/evaluate")
   public ResponseEntity<String> validateAndEvaluate(@RequestParam @Pattern(regexp = "[0-9+\-*/()]*") String expression) {
       // Przetwarzanie wyraÅ¼enia po walidacji
       return ResponseEntity.ok("Validated and processed");
   }
   ```

3. **Unikaj deserializacji niezaufanych danych**:
   - Korzystaj z bezpiecznych formatÃ³w przesyÅ‚ania danych, takich jak JSON czy protokoÅ‚y typu Protobuf, zamiast Java Serialization.

</details>

<details>
<summary>ğŸ”´ 2. Cross-Site Scripting (XSS)</summary>

### Opis
Cross-Site Scripting (XSS) to podatnoÅ›Ä‡, ktÃ³ra wystÄ™puje, gdy aplikacja wstrzykuje niesprawdzone dane uÅ¼ytkownika do odpowiedzi HTML, umoÅ¼liwiajÄ…c wykonanie zÅ‚oÅ›liwego kodu JavaScript w przeglÄ…darce ofiary. W Springu podatnoÅ›Ä‡ ta moÅ¼e wystÄ…piÄ‡, jeÅ›li dane wejÅ›ciowe uÅ¼ytkownika sÄ… bezpoÅ›rednio renderowane na stronie bez odpowiedniego zabezpieczenia.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class XSSController {

    @GetMapping("/greet")
    public String greetUser(@RequestParam String name) {
        // BezpoÅ›rednie wstawienie danych uÅ¼ytkownika w odpowiedzi HTML
        return "<html><body>Hello, " + name + "!</body></html>";
    }
}
```

**Dlaczego podatny?**  
- Dane wejÅ›ciowe uÅ¼ytkownika (`name`) sÄ… wstawiane bez walidacji lub escapingu.
- AtakujÄ…cy moÅ¼e przesÅ‚aÄ‡ zÅ‚oÅ›liwy kod, np. `<script>alert('Hacked!')</script>`, ktÃ³ry zostanie wykonany w przeglÄ…darce uÅ¼ytkownika.

---

### Skutki
- Wykonanie zÅ‚oÅ›liwego kodu JavaScript w przeglÄ…darce ofiary.
- KradzieÅ¼ danych sesyjnych lub poufnych informacji.
- Podszywanie siÄ™ pod uÅ¼ytkownika (session hijacking).

---

### Zalecenia
1. **Escaping danych wyjÅ›ciowych**:
   ```java
   @RestController
   public class XSSController {

       @GetMapping("/greet")
       public String greetUser(@RequestParam String name) {
           // Escaping danych uÅ¼ytkownika
           String escapedName = HtmlUtils.htmlEscape(name);
           return "<html><body>Hello, " + escapedName + "!</body></html>";
       }
   }
   ```

   **Dlaczego bezpieczny?**  
   - Funkcja `HtmlUtils.htmlEscape` zamienia specjalne znaki na ich bezpieczne odpowiedniki HTML (np. `<` na `&lt;`).

2. **UÅ¼ycie szablonÃ³w JSP lub Thymeleaf z automatycznym escapowaniem**:
   - Thymeleaf automatycznie escapuje dane uÅ¼ytkownika:
     ```html
     <p th:text="${name}">Hello, User!</p>
     ```

---

### Mechanizmy Spring Security
1. **SecurityFilterChain**:
   - Spring Security domyÅ›lnie zapewnia ochronÄ™ przed XSS za pomocÄ… `SecurityFilterChain`, ktÃ³ry filtruje dane wejÅ›ciowe i odpowiedzi HTTP.
   - Konfiguracja w Spring Boot:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http
                 .csrf() // WÅ‚Ä…cz ochronÄ™ przed CSRF
                 .and()
                 .headers()
                 .xssProtection()
                 .block(false); // WÅ‚Ä…cza podstawowe zabezpieczenia XSS
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - `SecurityFilterChain` automatycznie filtruje i blokuje potencjalne ataki XSS.

2. **UÅ¼ycie CSP (Content Security Policy)**:
   - Dodanie nagÅ‚Ã³wka Content-Security-Policy do odpowiedzi:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http
                 .headers()
                 .contentSecurityPolicy("script-src 'self'");
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - CSP ogranicza moÅ¼liwoÅ›Ä‡ wykonywania skryptÃ³w tylko do zaufanych ÅºrÃ³deÅ‚.

3. **Walidacja danych wejÅ›ciowych**:
   - Waliduj dane uÅ¼ytkownika przed ich przetwarzaniem:
     ```java
     @GetMapping("/greet")
     public String validateAndGreetUser(@RequestParam @Size(max = 50) String name) {
         return "<html><body>Hello, " + HtmlUtils.htmlEscape(name) + "!</body></html>";
     }
     ```

     **Dlaczego bezpieczne?**  
     - Walidacja ogranicza wielkoÅ›Ä‡ i zakres akceptowanych danych wejÅ›ciowych.

</details>

<details>
<summary>ğŸ”´ 3. Cross-Site Request Forgery (CSRF)</summary>

### Opis
Cross-Site Request Forgery (CSRF) to podatnoÅ›Ä‡, w ktÃ³rej atakujÄ…cy wykorzystuje uwierzytelnionÄ… sesjÄ™ uÅ¼ytkownika do wykonania nieautoryzowanych akcji w aplikacji webowej. W Springu podatnoÅ›Ä‡ ta moÅ¼e wystÄ…piÄ‡, jeÅ›li aplikacja nie stosuje tokenÃ³w CSRF lub gdy endpointy API sÄ… niewÅ‚aÅ›ciwie chronione.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class CSRFController {

    @PostMapping("/transfer")
    public ResponseEntity<String> transferFunds(@RequestParam String account, @RequestParam double amount) {
        // Brak weryfikacji, czy Å¼Ä…danie pochodzi od autoryzowanego uÅ¼ytkownika
        return ResponseEntity.ok("Transferred " + amount + " to " + account);
    }
}
```

**Dlaczego podatny?**  
- Endpoint `/transfer` nie wymaga Å¼adnego mechanizmu weryfikacji, czy Å¼Ä…danie pochodzi z zaufanego ÅºrÃ³dÅ‚a.
- AtakujÄ…cy moÅ¼e osadziÄ‡ zÅ‚oÅ›liwy formularz HTML w swojej witrynie, aby wymusiÄ‡ Å¼Ä…danie na uwierzytelnionym uÅ¼ytkowniku.

---

### Skutki
- Nieautoryzowane wykonanie akcji, takich jak przelewy, zmiana danych uÅ¼ytkownika lub modyfikacja ustawieÅ„.
- Naruszenie integralnoÅ›ci i bezpieczeÅ„stwa danych.

---

### Zalecenia
1. **WÅ‚Ä…czenie ochrony CSRF w Spring Security**:
   - DomyÅ›lnie Spring Security chroni przed CSRF. MoÅ¼na to skonfigurowaÄ‡ w `SecurityFilterChain`:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http
                 .csrf() // WÅ‚Ä…cza ochronÄ™ przed CSRF
                 .and()
                 .authorizeRequests()
                 .anyRequest().authenticated(); // Wszystkie Å¼Ä…dania muszÄ… byÄ‡ uwierzytelnione
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Token CSRF jest generowany dla kaÅ¼dego Å¼Ä…dania i weryfikowany na serwerze.

2. **UÅ¼ycie tokenÃ³w CSRF w Å¼Ä…daniach**:
   - Token CSRF naleÅ¼y przesyÅ‚aÄ‡ w kaÅ¼dym Å¼Ä…daniu POST:
     ```html
     <form method="POST" action="/transfer">
         <input type="hidden" name="_csrf" value="${_csrf.token}" />
         <input type="text" name="account" placeholder="Account" />
         <input type="number" name="amount" placeholder="Amount" />
         <button type="submit">Transfer</button>
     </form>
     ```

     **Dlaczego bezpieczne?**  
     - Serwer weryfikuje poprawnoÅ›Ä‡ tokenu CSRF przed wykonaniem akcji.

3. **WyÅ‚Ä…czanie ochrony CSRF dla endpointÃ³w API (jeÅ›li to konieczne)**:
   - JeÅ›li API korzysta z tokenÃ³w uwierzytelniajÄ…cych, moÅ¼na wyÅ‚Ä…czyÄ‡ CSRF:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http
                 .csrf().disable() // WyÅ‚Ä…cza CSRF dla REST API
                 .authorizeRequests()
                 .anyRequest().authenticated(); // Wszystkie Å¼Ä…dania muszÄ… byÄ‡ uwierzytelnione
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Tokeny uwierzytelniajÄ…ce (np. JWT) zastÄ™pujÄ… funkcjÄ™ tokenÃ³w CSRF w przypadku API.

4. **Dodanie nagÅ‚Ã³wkÃ³w `SameSite` dla ciasteczek**:
   - Ustaw nagÅ‚Ã³wek `SameSite` na `Strict` lub `Lax`:
     ```java
     @Bean
     public WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> cookieConfig() {
         return factory -> factory.addInitializers(
             new WebServerInitializer(new SameSiteCookieConfig("Strict")));
     }
     ```

     **Dlaczego bezpieczne?**  
     - Ciasteczka nie sÄ… przesyÅ‚ane w Å¼Ä…daniach pochodzÄ…cych z innych domen.

</details>

<details>
<summary>ğŸ”´ 4. SQL Injection (SQLi)</summary>

### Opis
SQL Injection (SQLi) to podatnoÅ›Ä‡, w ktÃ³rej atakujÄ…cy wstrzykuje zÅ‚oÅ›liwy kod SQL do zapytania, manipulujÄ…c danymi wejÅ›ciowymi. W Spring Data JPA problem ten moÅ¼e wystÄ…piÄ‡, gdy programista uÅ¼ywa zapytaÅ„ dynamicznych zbudowanych w oparciu o dane uÅ¼ytkownika bez ich odpowiedniego zabezpieczenia.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@Repository
public class UserRepository {

    @PersistenceContext
    private EntityManager entityManager;

    public List<User> findByUsername(String username) {
        // Dynamiczne zapytanie SQL z wstrzykniÄ™tymi danymi uÅ¼ytkownika
        String query = "SELECT u FROM User u WHERE u.username = '" + username + "'";
        return entityManager.createQuery(query, User.class).getResultList();
    }
}
```

**Dlaczego podatny?**  
- UÅ¼ytkownik moÅ¼e przesÅ‚aÄ‡ zÅ‚oÅ›liwy ciÄ…g znakÃ³w, np. `' OR '1'='1`, co spowoduje wykonanie zÅ‚oÅ›liwego zapytania SQL, zwracajÄ…c wszystkie rekordy w tabeli.

---

### Skutki
- Nieautoryzowany dostÄ™p do danych.
- MoÅ¼liwoÅ›Ä‡ usuniÄ™cia, modyfikacji lub odczytania poufnych danych.
- Potencjalne przejÄ™cie kontroli nad bazÄ… danych.

---

### Zalecenia
1. **UÅ¼ycie zapytaÅ„ z parametrami (Prepared Statements)**:
   ```java
   @Repository
   public interface UserRepository extends JpaRepository<User, Long> {

       @Query("SELECT u FROM User u WHERE u.username = :username")
       List<User> findByUsername(@Param("username") String username);
   }
   ```

   **Dlaczego bezpieczne?**  
   - W Spring Data JPA parametry w zapytaniach sÄ… automatycznie escapowane, co zapobiega wstrzykniÄ™ciom SQL.

2. **Korzystanie z metod zapytaÅ„ Spring Data JPA**:
   ```java
   @Repository
   public interface UserRepository extends JpaRepository<User, Long> {

       // Metoda zapytania generowana automatycznie na podstawie nazwy metody
       List<User> findByUsername(String username);
   }
   ```

   **Dlaczego bezpieczne?**  
   - Spring Data JPA automatycznie generuje zapytania SQL z uÅ¼yciem parametrÃ³w, eliminujÄ…c ryzyko SQL Injection.

---

### Mechanizmy Spring Security
1. **Walidacja danych wejÅ›ciowych**:
   - UÅ¼ywaj adnotacji takich jak `@Pattern` lub `@Size` do walidacji danych wejÅ›ciowych:
     ```java
     @RestController
     public class UserController {

         @GetMapping("/users")
         public List<User> getUsers(@RequestParam @Pattern(regexp = "^[a-zA-Z0-9]*$") String username) {
             return userRepository.findByUsername(username);
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Walidacja ogranicza dane wejÅ›ciowe do akceptowalnych wartoÅ›ci.

2. **Monitorowanie i rejestrowanie aktywnoÅ›ci bazy danych**:
   - UÅ¼ycie mechanizmÃ³w monitorowania zapytaÅ„, takich jak Hibernate Envers lub logi bazy danych, aby wykryÄ‡ nietypowe wzorce zapytaÅ„.

3. **UÅ¼ycie ORM (Object-Relational Mapping)**:
   - Korzystaj z JPA i Hibernate zamiast natywnych zapytaÅ„ SQL. ORM zapewnia domyÅ›lne zabezpieczenia przed SQL Injection.

</details>

## A04:2021 Insecure Design

<details>
<summary>ğŸ”´ 1. Open Redirect</summary>

### Opis
Open Redirect to podatnoÅ›Ä‡, ktÃ³ra pozwala atakujÄ…cemu na przekierowanie uÅ¼ytkownika na zewnÄ™trznÄ…, zÅ‚oÅ›liwÄ… stronÄ™ internetowÄ…. W Springu problem ten moÅ¼e wystÄ…piÄ‡, jeÅ›li aplikacja uÅ¼ywa przekierowaÅ„ na podstawie danych wejÅ›ciowych uÅ¼ytkownika bez odpowiedniej walidacji lub ograniczeÅ„.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class RedirectController {

    @GetMapping("/redirect")
    public ResponseEntity<Void> redirect(@RequestParam String url) {
        // Niebezpieczne przekierowanie na adres URL dostarczony przez uÅ¼ytkownika
        return ResponseEntity.status(HttpStatus.FOUND)
                .location(URI.create(url))
                .build();
    }
}
```

**Dlaczego podatny?**  
- UÅ¼ytkownik moÅ¼e dostarczyÄ‡ zÅ‚oÅ›liwy adres URL, np. `http://malicious-site.com`, ktÃ³ry zostanie uÅ¼yty do przekierowania ofiary.
- Aplikacja nie weryfikuje, czy adres URL jest zaufany.

---

### Skutki
- Przekierowanie uÅ¼ytkownika na zÅ‚oÅ›liwe strony internetowe.
- KradzieÅ¼ danych uwierzytelniajÄ…cych (phishing).

---

### Zalecenia
1. **Ograniczenie przekierowaÅ„ do zaufanych domen**:
   ```java
   @RestController
   public class RedirectController {

       private static final List<String> TRUSTED_DOMAINS = List.of("example.com", "trusted.com");

       @GetMapping("/redirect")
       public ResponseEntity<Void> redirect(@RequestParam String url) {
           URI uri = URI.create(url);

           // Weryfikacja, czy domena jest zaufana
           if (TRUSTED_DOMAINS.stream().noneMatch(uri.getHost()::endsWith)) {
               return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
           }

           return ResponseEntity.status(HttpStatus.FOUND)
                   .location(uri)
                   .build();
       }
   }
   ```

   **Dlaczego bezpieczne?**  
   - Przekierowanie odbywa siÄ™ tylko do zaufanych domen.
   - Blokuje moÅ¼liwoÅ›Ä‡ uÅ¼ycia niezaufanych adresÃ³w URL.

---

### Mechanizmy Spring Security
1. **WÅ‚Ä…czenie nagÅ‚Ã³wkÃ³w zabezpieczajÄ…cych przekierowania**:
   - Spring Security automatycznie ustawia nagÅ‚Ã³wki takie jak `X-Content-Type-Options` i `X-Frame-Options`, ktÃ³re mogÄ… pomÃ³c w ochronie przed zÅ‚oÅ›liwymi przekierowaniami.

2. **Filtrowanie danych wejÅ›ciowych**:
   - MoÅ¼na zastosowaÄ‡ adnotacje `@Valid` oraz `@Pattern`, aby ograniczyÄ‡ potencjalnie zÅ‚oÅ›liwe dane wejÅ›ciowe.


</details>

<details>
<summary>ğŸ”´ 2. Login Rate Limiting</summary>

### Opis
Brak mechanizmu ograniczania liczby Å¼Ä…daÅ„ (rate limiting) w aplikacji moÅ¼e prowadziÄ‡ do atakÃ³w typu brute force lub denial of service (DoS). W Spring REST API problem ten wystÄ™puje, gdy aplikacja nie weryfikuje, ile Å¼Ä…daÅ„ logowania pochodzi od konkretnego klienta w okreÅ›lonym czasie.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class LoginController {

    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestParam String username, @RequestParam String password) {
        // Brak ograniczenia liczby prÃ³b logowania
        boolean success = authenticate(username, password);
        return success ? ResponseEntity.ok("Login successful") : ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
    }

    private boolean authenticate(String username, String password) {
        // Prosta weryfikacja logowania
        return "user".equals(username) && "password".equals(password);
    }
}
```

**Dlaczego podatny?**  
- AtakujÄ…cy moÅ¼e wysyÅ‚aÄ‡ nieograniczonÄ… liczbÄ™ Å¼Ä…daÅ„ logowania, prÃ³bujÄ…c odgadnÄ…Ä‡ dane uwierzytelniajÄ…ce.
- Brak jakichkolwiek mechanizmÃ³w rate limiting pozwala na wykorzystanie zasobÃ³w serwera, co moÅ¼e prowadziÄ‡ do ataku DoS.

---

### Skutki
- MoÅ¼liwoÅ›Ä‡ przeprowadzenia skutecznych atakÃ³w brute force.
- ObciÄ…Å¼enie serwera i ograniczenie dostÄ™pnoÅ›ci usÅ‚ugi (atak DoS).
- Naruszenie bezpieczeÅ„stwa uÅ¼ytkownikÃ³w.

---

### Zalecenia
1. **Wprowadzenie limitu liczby Å¼Ä…daÅ„ (Rate Limiting)**:
   - UÅ¼yj biblioteki takiej jak Bucket4j, aby ograniczyÄ‡ liczbÄ™ Å¼Ä…daÅ„:
     ```java
     @RestController
     public class LoginController {

         private final Bucket bucket = Bucket4j.builder()
                 .addLimit(Bandwidth.simple(5, Duration.ofMinutes(1))) // 5 Å¼Ä…daÅ„ na minutÄ™
                 .build();

         @PostMapping("/login")
         public ResponseEntity<String> login(@RequestParam String username, @RequestParam String password) {
             if (!bucket.tryConsume(1)) {
                 return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body("Too many login attempts. Please try again later.");
             }

             boolean success = authenticate(username, password);
             return success ? ResponseEntity.ok("Login successful") : ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
         }

         private boolean authenticate(String username, String password) {
             return "user".equals(username) && "password".equals(password);
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Mechanizm Bucket4j ogranicza liczbÄ™ Å¼Ä…daÅ„ w okreÅ›lonym czasie, chroniÄ…c przed brute force i DoS.

2. **Blokowanie uÅ¼ytkownikÃ³w po okreÅ›lonej liczbie nieudanych prÃ³b**:
   - Dodaj funkcjonalnoÅ›Ä‡ blokady konta po okreÅ›lonej liczbie nieudanych prÃ³b logowania:
     ```java
     @Service
     public class LoginAttemptService {

         private final Map<String, Integer> loginAttempts = new ConcurrentHashMap<>();
         private static final int MAX_ATTEMPTS = 5;

         public void loginFailed(String username) {
             loginAttempts.put(username, loginAttempts.getOrDefault(username, 0) + 1);
         }

         public boolean isBlocked(String username) {
             return loginAttempts.getOrDefault(username, 0) >= MAX_ATTEMPTS;
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Zapobiega nieograniczonej liczbie prÃ³b logowania, blokujÄ…c uÅ¼ytkownikÃ³w po okreÅ›lonej liczbie nieudanych prÃ³b.

3. **Dodanie reCAPTCHA do procesu logowania**:
   - Po okreÅ›lonej liczbie prÃ³b logowania dodaj weryfikacjÄ™ CAPTCHA.


---

### Mechanizmy Spring Security
1. **Rate limiting przy uÅ¼yciu SecurityFilterChain**:
   - MoÅ¼esz dodaÄ‡ filtr ograniczajÄ…cy liczbÄ™ Å¼Ä…daÅ„:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http
                 .addFilterBefore(new RateLimitingFilter(), UsernamePasswordAuthenticationFilter.class);
             return http.build();
         }
     }

     public class RateLimitingFilter extends GenericFilterBean {

         private final Bucket bucket = Bucket4j.builder()
                 .addLimit(Bandwidth.simple(5, Duration.ofMinutes(1))) // 5 Å¼Ä…daÅ„ na minutÄ™
                 .build();

         @Override
         public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
             if (!bucket.tryConsume(1)) {
                 ((HttpServletResponse) response).setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
                 return;
             }
             chain.doFilter(request, response);
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Filtr ogranicza liczbÄ™ Å¼Ä…daÅ„ na poziomie warstwy zabezpieczeÅ„ Spring Security.


</details>

## A05:2021 Security Misconfiguration

<details>
<summary>ğŸ”´ 1. Token/Cookie no expire </summary>

### Opis
PodatnoÅ›Ä‡ wystÄ™puje, gdy tokeny JWT lub ciasteczka sesyjne sÄ… generowane bez ustawionego czasu wygaÅ›niÄ™cia (`expiration time`) lub zbyt dÅ‚ugim czasem waÅ¼noÅ›ci. W przypadku JWT brak pola `exp` w payloadzie, a w przypadku ciasteczek brak atrybutÃ³w `Expires` lub `Max-Age`. Tokeny takie pozostajÄ… waÅ¼ne bezterminowo, co stanowi powaÅ¼ne zagroÅ¼enie bezpieczeÅ„stwa w przypadku ich przechwycenia.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
public String generateToken(String username) {
    // Token JWT bez ustawionego czasu wygaÅ›niÄ™cia
    return Jwts.builder()
            .setSubject(username)
            .signWith(SignatureAlgorithm.HS512, SECRET_KEY)
            .compact();
}
```

**Dlaczego podatny?**  
- Brak ustawionego pola `exp` powoduje, Å¼e token pozostaje waÅ¼ny bezterminowo.
- W przypadku przechwycenia tokenu atakujÄ…cy moÅ¼e uÅ¼ywaÄ‡ go bez ograniczeÅ„.

---

### Skutki
- **Przechwycone tokeny/cookie mogÄ… byÄ‡ uÅ¼ywane bezterminowo.**
- **Brak moÅ¼liwoÅ›ci wymuszenia ponownego logowania.**
- **ZwiÄ™kszone ryzyko atakÃ³w zwiÄ…zanych z kradzieÅ¼Ä… sesji.**
- **Problemy z uniewaÅ¼nieniem sesji po zmianie uprawnieÅ„ uÅ¼ytkownika.**

---

### Zalecenia
1. **Ustawienie daty wygaÅ›niÄ™cia w tokenach JWT**:
   ```java
   public String generateToken(String username) {
       Date now = new Date();
       Date expiryDate = new Date(now.getTime() + 3600000); // 1 godzina

       return Jwts.builder()
               .setSubject(username)
               .setIssuedAt(now)
               .setExpiration(expiryDate) // Dodaj czas wygaÅ›niÄ™cia
               .signWith(SignatureAlgorithm.HS512, SECRET_KEY)
               .compact();
   }
   ```

   **Dlaczego bezpieczne?**  
   - Token automatycznie traci waÅ¼noÅ›Ä‡ po okreÅ›lonym czasie, co minimalizuje ryzyko jego naduÅ¼ycia.

2. **Ustawienie daty wygaÅ›niÄ™cia dla ciasteczek**:
   ```java
   @RestController
   public class CookieController {

       @PostMapping("/set-cookie")
       public ResponseEntity<Void> setCookie(HttpServletResponse response) {
           Cookie cookie = new Cookie("sessionId", "randomSessionValue");
           cookie.setHttpOnly(true);
           cookie.setSecure(true);
           cookie.setMaxAge(3600); // Czas wygaÅ›niÄ™cia 1 godzina
           response.addCookie(cookie);
           return ResponseEntity.ok().build();
       }
   }
   ```

   **Dlaczego bezpieczne?**  
   - Ogranicza czas Å¼ycia ciasteczka, zmniejszajÄ…c ryzyko jego wykorzystania w przypadku przechwycenia.

3. **UniewaÅ¼nienie tokenÃ³w po zmianie uprawnieÅ„**:
   - UÅ¼yj bazy danych lub systemu zarzÄ…dzania sesjami, aby przechowywaÄ‡ aktywne tokeny i weryfikowaÄ‡ ich waÅ¼noÅ›Ä‡.

4. **Regularne odÅ›wieÅ¼anie tokenÃ³w (Refresh Tokens)**:
   - WprowadÅº mechanizm odÅ›wieÅ¼ania tokenÃ³w, aby ograniczyÄ‡ czas Å¼ycia tokenÃ³w dostÄ™powych.
  
### Mechanizmy Spring Security
1. **Automatyczne zarzÄ…dzanie sesjami**:
   - Spring Security zapewnia automatyczne zarzÄ…dzanie sesjami, co umoÅ¼liwia wymuszanie wygasania sesji:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http.sessionManagement()
                     .invalidSessionUrl("/login?expired=true")
                     .maximumSessions(1) // Ograniczenie do jednej aktywnej sesji na uÅ¼ytkownika
                     .expiredUrl("/login?expired=true"); // Przekierowanie po wygaÅ›niÄ™ciu sesji
             return http.build();
         }
     }
     ```

   **Dlaczego bezpieczne?**  
   - Pozwala ograniczyÄ‡ liczbÄ™ aktywnych sesji dla jednego uÅ¼ytkownika i wymusza ich uniewaÅ¼nienie.

2. **Weryfikacja daty wygaÅ›niÄ™cia tokenÃ³w JWT**:
   - Zaimplementuj filtr weryfikujÄ…cy datÄ™ wygaÅ›niÄ™cia tokenÃ³w:
     ```java
     @Component
     public class JwtAuthenticationFilter extends OncePerRequestFilter {

         @Override
         protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
                 throws ServletException, IOException {
             String token = request.getHeader("Authorization");
             if (token != null && !isTokenExpired(token)) {
                 // Token waÅ¼ny - kontynuacja przetwarzania
             } else {
                 response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
             }
             chain.doFilter(request, response);
         }

         private boolean isTokenExpired(String token) {
             Claims claims = Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token).getBody();
             return claims.getExpiration().before(new Date());
         }
     }
     ```

   **Dlaczego bezpieczne?**  
   - UniemoÅ¼liwia uÅ¼ywanie tokenÃ³w po ich wygaÅ›niÄ™ciu, wymuszajÄ…c ponowne logowanie.


</details>

<details>
<summary>ğŸ”´ 2. Distributed Denial of Service (DDoS)</summary>

### Opis
Ataki typu Distributed Denial of Service (DDoS) polegajÄ… na zalewaniu serwera ogromnÄ… liczbÄ… Å¼Ä…daÅ„ z wielu ÅºrÃ³deÅ‚, co powoduje wyczerpanie zasobÃ³w i brak dostÄ™pnoÅ›ci usÅ‚ugi dla normalnych uÅ¼ytkownikÃ³w. W kontekÅ›cie Spring Framework ochrona przed DDoS moÅ¼e byÄ‡ realizowana poprzez rÃ³Å¼ne techniki, takie jak filtrowanie ruchu, dynamiczne blokowanie adresÃ³w IP oraz ograniczanie przepustowoÅ›ci.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class ExampleController {

    @GetMapping("/data")
    public ResponseEntity<String> fetchData() {
        // Brak ograniczeÅ„ liczby Å¼Ä…daÅ„, co pozwala na zalewanie serwera
        return ResponseEntity.ok("Data fetched successfully");
    }
}
```

**Dlaczego podatny?**  
- Brak jakiegokolwiek mechanizmu kontrolujÄ…cego liczbÄ™ Å¼Ä…daÅ„ lub ich ÅºrÃ³dÅ‚o.
- AtakujÄ…cy moÅ¼e wysyÅ‚aÄ‡ nieograniczonÄ… liczbÄ™ Å¼Ä…daÅ„, co prowadzi do przeciÄ…Å¼enia serwera.

---

### Skutki
- NiedostÄ™pnoÅ›Ä‡ usÅ‚ugi dla normalnych uÅ¼ytkownikÃ³w.
- Wyczerpanie zasobÃ³w serwera, takich jak CPU, pamiÄ™Ä‡ czy przepustowoÅ›Ä‡ sieci.
- Potencjalne zwiÄ™kszenie kosztÃ³w operacyjnych (np. w modelach chmurowych).

---

### Zalecenia
1. **Implementacja dynamicznego filtrowania ruchu**:
   - PrzykÅ‚ad kodu dynamicznie ograniczajÄ…cego liczbÄ™ Å¼Ä…daÅ„ z tego samego adresu IP:
     ```java
     @Component
     @Order(1)
     public class RateLimitFilter implements Filter {

         private final ConcurrentHashMap<String, AtomicLong> requestCount = new ConcurrentHashMap<>();
         private final long rateLimit = 10; // Maksymalna liczba Å¼Ä…daÅ„ na okres czasu

         @Override
         public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
             String ipAddress = request.getRemoteAddr();
             AtomicLong count = requestCount.computeIfAbsent(ipAddress, k -> new AtomicLong());

             // Sprawdzenie, czy liczba Å¼Ä…daÅ„ przekracza limit
             if (count.incrementAndGet() > rateLimit) {
                 HttpServletResponse httpResponse = (HttpServletResponse) response;
                 httpResponse.setStatus(HttpServletResponse.SC_TOO_MANY_REQUESTS);
                 httpResponse.getWriter().write("Rate limit exceeded. Please try again later.");
                 return;
             }

             chain.doFilter(request, response);
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - DziaÅ‚a na poziomie filtrÃ³w HTTP, rejestrujÄ…c liczbÄ™ Å¼Ä…daÅ„ na podstawie adresu IP.
     - Blokuje adresy IP, ktÃ³re przekroczÄ… zdefiniowany limit Å¼Ä…daÅ„.

---

### Mechanizmy Spring Security

1. **Konfiguracja timeoutÃ³w w Spring Boot**:
   - Ustaw odpowiednie timeouty dla Å¼Ä…daÅ„ HTTP:
     ```properties
     server.connection-timeout=5000
     spring.mvc.async.request-timeout=5000
     ```

     **Dlaczego bezpieczne?**  
     - Ogranicza czas przetwarzania Å¼Ä…daÅ„, co zapobiega blokowaniu zasobÃ³w przez dÅ‚ugotrwaÅ‚e Å¼Ä…dania.

</details>

<details>
<summary>ğŸ”´ 3. TLS force/HSTS</summary>

### Opis
TLS (Transport Layer Security) zapewnia szyfrowanie danych przesyÅ‚anych pomiÄ™dzy klientem a serwerem, chroniÄ…c je przed przechwyceniem (np. w atakach typu Man-in-the-Middle). Brak wymuszania TLS lub brak nagÅ‚Ã³wka HSTS (HTTP Strict Transport Security) w odpowiedziach HTTP moÅ¼e pozwoliÄ‡ na przesyÅ‚anie danych w sposÃ³b niezaszyfrowany, co stanowi zagroÅ¼enie dla bezpieczeÅ„stwa aplikacji.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
public class ExampleController {

    @GetMapping("/data")
    public ResponseEntity<String> fetchData() {
        // Brak zabezpieczenia transmisji TLS
        return ResponseEntity.ok("Sensitive data");
    }
}
```

**Dlaczego podatny?**  
- JeÅ›li aplikacja dopuszcza komunikacjÄ™ za pomocÄ… HTTP zamiast HTTPS, dane sÄ… przesyÅ‚ane w sposÃ³b niezaszyfrowany.
- Brak nagÅ‚Ã³wka HSTS umoÅ¼liwia ataki typu downgrade, w ktÃ³rych uÅ¼ytkownik jest przekierowany do nieszyfrowanej wersji aplikacji.

---

### Skutki
- MoÅ¼liwoÅ›Ä‡ przechwycenia wraÅ¼liwych danych przez atakujÄ…cych.
- Ataki typu Man-in-the-Middle (MITM) i downgrade protokoÅ‚u.
- Naruszenie poufnoÅ›ci danych uÅ¼ytkownikÃ³w.

---

### Zalecenia
1. **Wymuszenie HTTPS w konfiguracji Spring Security**:
   - Skonfiguruj `HttpSecurity`, aby wymusiÄ‡ HTTPS:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http.requiresChannel()
                 .anyRequest()
                 .requiresSecure(); // Wymusza HTTPS na wszystkich Å¼Ä…daniach
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Zapewnia, Å¼e wszystkie Å¼Ä…dania sÄ… przesyÅ‚ane przez HTTPS, eliminujÄ…c moÅ¼liwoÅ›Ä‡ przesyÅ‚ania danych w sposÃ³b niezaszyfrowany.

2. **Dodanie nagÅ‚Ã³wka HSTS**:
   - Konfiguracja Spring Security, aby automatycznie dodawaÄ‡ nagÅ‚Ã³wek HSTS:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http.headers()
                 .httpStrictTransportSecurity()
                 .includeSubDomains(true)
                 .maxAgeInSeconds(31536000); // 1 rok
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - HSTS wymusza, aby przeglÄ…darka zawsze korzystaÅ‚a z HTTPS, nawet jeÅ›li uÅ¼ytkownik rÄ™cznie wpisze adres HTTP.

3. **Konfiguracja SSL/TLS w Spring Boot**:
   - Skonfiguruj certyfikat SSL w `application.properties`:
     ```properties
     server.ssl.key-store=classpath:keystore.p12
     server.ssl.key-store-password=yourPassword
     server.ssl.key-store-type=PKCS12
     server.port=8443
     ```

     **Dlaczego bezpieczne?**  
     - Certyfikat SSL/TLS zapewnia szyfrowanie transmisji danych miÄ™dzy klientem a serwerem.

4. **Przekierowanie HTTP do HTTPS**:
   - Dodaj reguÅ‚Ä™ przekierowania w serwerze aplikacji (np. Tomcat, Nginx) lub konfiguracji Spring Boot:
     ```java
     @Configuration
     public class HttpToHttpsRedirectConfig {

         @Bean
         public WebServerFactoryCustomizer<TomcatServletWebServerFactory> redirectConfig() {
             return factory -> factory.addAdditionalTomcatConnectors(httpToHttpsRedirectConnector());
         }

         private Connector httpToHttpsRedirectConnector() {
             Connector connector = new Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);
             connector.setScheme("http");
             connector.setPort(8080);
             connector.setSecure(false);
             connector.setRedirectPort(8443);
             return connector;
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Automatycznie przekierowuje uÅ¼ytkownikÃ³w korzystajÄ…cych z HTTP do HTTPS, eliminujÄ…c ryzyko przesyÅ‚ania danych w sposÃ³b niezaszyfrowany.

5. **Monitorowanie protokoÅ‚u TLS**:
   - Regularnie weryfikuj uÅ¼ywane wersje TLS (zaleca siÄ™ korzystanie z TLS 1.2 lub nowszego).

---

### Mechanizmy Spring Security
1. **WÅ‚Ä…czenie nagÅ‚Ã³wkÃ³w zabezpieczajÄ…cych**:
   - Spring Security automatycznie dodaje nagÅ‚Ã³wki zabezpieczajÄ…ce, takie jak `Strict-Transport-Security`, `X-Content-Type-Options`, i `X-Frame-Options`, zwiÄ™kszajÄ…c ochronÄ™ aplikacji.

2. **ObsÅ‚uga certyfikatÃ³w klienta**:
   - Spring Security umoÅ¼liwia wymuszanie uwierzytelniania TLS na podstawie certyfikatÃ³w klienta w konfiguracji.


</details>

<details>
<summary>ğŸ”´ 4. Debug Mode Enabled</summary>

### Opis
Debug Mode to tryb diagnostyczny, ktÃ³ry ujawnia szczegÃ³Å‚owe informacje o aplikacji, takie jak konfiguracja serwera, stacktrace, szczegÃ³Å‚y bazy danych czy dane Å›rodowiskowe. WÅ‚Ä…czenie trybu debugowania w Å›rodowisku produkcyjnym stanowi powaÅ¼ne zagroÅ¼enie bezpieczeÅ„stwa, poniewaÅ¼ te informacje mogÄ… byÄ‡ wykorzystane przez atakujÄ…cych.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@RestController
@ControllerAdvice
public class DebugController {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception ex) {
        // WyÅ›wietlanie peÅ‚nego stacktrace w odpowiedzi
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ex.toString());
    }

    @GetMapping("/debug")
    public ResponseEntity<String> debugEndpoint() {
        // Ujawnienie szczegÃ³Å‚owych informacji o serwerze
        return ResponseEntity.ok("Debug Mode Enabled: Environment = " + System.getenv());
    }
}
```

**Dlaczego podatny?**  
- WyÅ›wietlanie stacktrace i danych Å›rodowiskowych ujawnia szczegÃ³Å‚y implementacji aplikacji i serwera.
- AtakujÄ…cy moÅ¼e wykorzystaÄ‡ te informacje do przeprowadzenia dalszych atakÃ³w, takich jak SQL Injection, RCE lub inne.

---

### Skutki
- Ujawnienie poufnych informacji o systemie, takich jak zmienne Å›rodowiskowe, dane bazy danych, wersje bibliotek czy szczegÃ³Å‚y konfiguracji.
- MoÅ¼liwoÅ›Ä‡ wykorzystania tych informacji przez atakujÄ…cych do przeprowadzenia dalszych atakÃ³w.
- Naruszenie zasad bezpieczeÅ„stwa danych.

---

### Zalecenia
1. **WyÅ‚Ä…cz debug mode w Å›rodowisku produkcyjnym**:
   - W pliku `application.properties` lub `application.yml` ustaw debugowanie jako wyÅ‚Ä…czone:
     ```properties
     spring.devtools.restart.enabled=false
     spring.main.banner-mode=off
     ```

     **Dlaczego bezpieczne?**  
     - Zapobiega wyÅ›wietlaniu szczegÃ³Å‚owych informacji diagnostycznych w Å›rodowisku produkcyjnym.


2. **Testowanie w Å›rodowisku testowym**:
   - Debug mode moÅ¼e byÄ‡ uÅ¼ywany wyÅ‚Ä…cznie w Å›rodowisku testowym lub deweloperskim poprzez rÃ³Å¼nicowanie konfiguracji:
     ```properties
     # application-dev.properties
     spring.devtools.restart.enabled=true
     spring.main.banner-mode=console

     # application-prod.properties
     spring.devtools.restart.enabled=false
     spring.main.banner-mode=off
     ```

---

### Mechanizmy Spring Security
1. **Kontrola dostÄ™pu do endpointÃ³w diagnostycznych**:
   - Ogranicz dostÄ™p do wraÅ¼liwych endpointÃ³w (np. /actuator) wyÅ‚Ä…cznie dla administratorÃ³w:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http.authorizeRequests()
                 .antMatchers("/actuator/**").hasRole("ADMIN") // Tylko dla administratorÃ³w
                 .anyRequest().authenticated();
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - UniemoÅ¼liwia nieautoryzowanym uÅ¼ytkownikom dostÄ™p do wraÅ¼liwych danych diagnostycznych.

2. **Ukrycie szczegÃ³Å‚owych informacji o bÅ‚Ä™dach**:
   - W Spring Security moÅ¼esz wÅ‚Ä…czyÄ‡ niestandardowÄ… stronÄ™ bÅ‚Ä™du:
     ```java
     @Configuration
     public class SecurityConfig {

         @Bean
         public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
             http.exceptionHandling()
                 .accessDeniedPage("/error/access-denied");
             return http.build();
         }
     }
     ```

     **Dlaczego bezpieczne?**  
     - Zapewnia, Å¼e szczegÃ³Å‚y bÅ‚Ä™dÃ³w sÄ… ukryte przed uÅ¼ytkownikiem.

</details>

## A09:2021 Security Logging and Monitoring Failures
<details>
<summary>Wprowadzenie do logowania w Spring Framework</summary>
    
### Spring Framework domyÅ›lnie obsÅ‚uguje logowanie za pomocÄ… popularnych bibliotek takich jak SLF4J i Logback. Logi sÄ… zapisywane w konsoli lub w plikach, w zaleÅ¼noÅ›ci od konfiguracji. Aby wÅ‚Ä…czyÄ‡ logowanie do plikÃ³w, wystarczy skonfigurowaÄ‡ `application.properties` lub `logback.xml`.

#### DomyÅ›lne ustawienia logowania
Spring Boot ma wbudowanÄ… konfiguracjÄ™ logowania, ktÃ³ra zapisuje logi na poziomie `INFO`. W aplikacji Spring Boot logi moÅ¼na znaleÅºÄ‡ w konsoli, chyba Å¼e skonfigurowano je do zapisywania w pliku.

#### PrzykÅ‚ad konfiguracji logowania
1. **Logi w pliku za pomocÄ… `application.properties`:**
   ```properties
   logging.file.name=app.log  # ÅšcieÅ¼ka do pliku z logami
   logging.level.root=INFO    # Poziom logowania (DEBUG, INFO, WARN, ERROR)
   logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
   logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
   ```

2. **Konfiguracja za pomocÄ… `logback.xml`:**
   ```xml
   <configuration>
       <appender name="FILE" class="ch.qos.logback.core.FileAppender">
           <file>app.log</file>
           <encoder>
               <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
           </encoder>
       </appender>
       <root level="INFO">
           <appender-ref ref="FILE" />
       </root>
   </configuration>
   ```
#### W Javie istnieje moÅ¼liwoÅ›Ä‡ logowania za pomocÄ… wbudowanej klasy java.util.logging.Logger, ktÃ³ra jest czÄ™Å›ciÄ… standardowej biblioteki Javy. Jednak w nowoczesnych aplikacjach rzadko uÅ¼ywa siÄ™ tej metody, poniewaÅ¼ oferuje ograniczone moÅ¼liwoÅ›ci w porÃ³wnaniu z popularnymi bibliotekami logowania, takimi jak SLF4J, Logback czy Log4j. 
</details>

<details>
<summary>ğŸ”´ 1. Password in Logs</summary>

### Opis
Zapisanie hasÅ‚a w logach moÅ¼e prowadziÄ‡ do naruszenia bezpieczeÅ„stwa, jeÅ›li logi dostanÄ… siÄ™ w niepowoÅ‚ane rÄ™ce. MoÅ¼e to byÄ‡ efektem logowania peÅ‚nych treÅ›ci Å¼Ä…daÅ„ lub odpowiedzi HTTP, ktÃ³re zawierajÄ… dane uwierzytelniajÄ…ce.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@PostMapping("/login")
public ResponseEntity<String> login(@RequestBody LoginRequest loginRequest) {
    log.info("User attempting login with password: {}", loginRequest.getPassword());
    return ResponseEntity.ok("Login successful");
}
```

**Dlaczego podatny?**  
- Logowanie hasÅ‚a wprost w logach powoduje, Å¼e dane uwierzytelniajÄ…ce sÄ… widoczne dla osÃ³b z dostÄ™pem do plikÃ³w logÃ³w.

---

### Zalecenia
1. **Unikaj logowania danych uwierzytelniajÄ…cych**:
   ```java
   log.info("User attempting login with username: {}", loginRequest.getUsername());
   ```

2. **Maskowanie poufnych danych**:
   - UÅ¼yj maskowania, aby ukryÄ‡ hasÅ‚o:
     ```java
     log.info("User attempting login with password: *****");
     ```

---

</details>

<details>
<summary>ğŸ”´ 2. Logging Enabled</summary>

### Opis
Brak wÅ‚Ä…czonego logowania lub niewystarczajÄ…ce logowanie moÅ¼e utrudniÄ‡ wykrywanie incydentÃ³w bezpieczeÅ„stwa. Logowanie powinno byÄ‡ zawsze wÅ‚Ä…czone w Å›rodowisku produkcyjnym, z odpowiednio dobranym poziomem logowania.

---

### PrzykÅ‚ad podatnoÅ›ci
- Brak logowania zdarzeÅ„ zwiÄ…zanych z bezpieczeÅ„stwem, takich jak nieudane prÃ³by logowania, zmiany uprawnieÅ„ czy podejrzane operacje.

---

### Zalecenia
1. **WÅ‚Ä…cz logowanie zdarzeÅ„ krytycznych**:
   - Loguj zdarzenia takie jak prÃ³by logowania, zmiany danych uÅ¼ytkownika czy bÅ‚Ä™dy aplikacji:
     ```java
     log.warn("Failed login attempt for user: {}", username);
     log.info("User {} changed their password", username);
     ```

2. **Korzystaj z odpowiedniego poziomu logowania**:
   - Ustaw poziom logowania na `INFO` lub `WARN` dla zdarzeÅ„ krytycznych.

---

</details>

<details>
<summary>ğŸ”´ 3. No Logs Exposed to User</summary>

### Opis
Eksponowanie logÃ³w uÅ¼ytkownikowi moÅ¼e ujawniÄ‡ wraÅ¼liwe informacje o systemie, takie jak stacktrace, szczegÃ³Å‚y implementacji czy inne dane diagnostyczne.

---

### PrzykÅ‚ad podatnoÅ›ci
```java
@ExceptionHandler(Exception.class)
public ResponseEntity<String> handleException(Exception ex) {
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(ex.toString());
}
```

**Dlaczego podatny?**  
- UÅ¼ytkownik otrzymuje peÅ‚ny stacktrace, ktÃ³ry moÅ¼e ujawniÄ‡ szczegÃ³Å‚y implementacji aplikacji.

---

### Zalecenia
1. **Unikaj ujawniania logÃ³w uÅ¼ytkownikowi**:
   ```java
   @ExceptionHandler(Exception.class)
   public ResponseEntity<String> handleException(Exception ex) {
       return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An unexpected error occurred.");
   }
   ```

2. **UÅ¼yj centralnego systemu logowania**:
   - Przechowuj logi w bezpiecznym miejscu, niedostÄ™pnym dla uÅ¼ytkownikÃ³w koÅ„cowych.

---

</details>

## A10:2021 Server Side Request Forgery (SSRF)

<details>
<summary>Server Side Request Forgery (SSRF)</summary>

### Opis ogÃ³lny podatnoÅ›ci
Server Side Request Forgery (SSRF) to podatnoÅ›Ä‡ umoÅ¼liwiajÄ…ca atakujÄ…cemu zmuszenie serwera aplikacyjnego do wykonania nieautoryzowanego Å¼Ä…dania HTTP. AtakujÄ…cy moÅ¼e wykorzystaÄ‡ podatnoÅ›Ä‡ do uzyskania dostÄ™pu do wewnÄ™trznych zasobÃ³w serwera, takich jak bazy danych, API lub panele administracyjne. Problem pojawia siÄ™, gdy serwer wykonuje Å¼Ä…dania HTTP na podstawie danych wejÅ›ciowych uÅ¼ytkownika bez odpowiedniej walidacji.

---

### Potencjalne skutki
- **Nieautoryzowany dostÄ™p do wewnÄ™trznych zasobÃ³w serwera**: moÅ¼liwoÅ›Ä‡ odczytu lub modyfikacji danych.
- **Wykorzystanie serwera jako poÅ›rednika**: atakujÄ…cy moÅ¼e uÅ¼ywaÄ‡ serwera aplikacyjnego do przeprowadzania atakÃ³w na inne systemy.
- **Skuteczne ataki na metadane instancji chmurowych**: w Å›rodowiskach chmurowych (np. AWS, Azure), SSRF moÅ¼e prowadziÄ‡ do wycieku kluczy API lub innych danych uwierzytelniajÄ…cych.

---

### Zalecenia dla frameworka
1. **Walidacja danych wejÅ›ciowych**:
   - UÅ¼ywaj biaÅ‚ej listy zaufanych domen lub wzorcÃ³w URL, aby ograniczyÄ‡ ÅºrÃ³dÅ‚a Å¼Ä…daÅ„.
   - Sprawdzaj, czy Å¼Ä…dania nie sÄ… kierowane do wewnÄ™trznych adresÃ³w IP (np. `127.0.0.1`, `169.254.x.x`).

2. **Ograniczenie uprawnieÅ„ serwera**:
   - Konfiguruj uprawnienia sieciowe tak, aby serwer aplikacyjny nie miaÅ‚ dostÄ™pu do wraÅ¼liwych zasobÃ³w wewnÄ™trznych.

3. **Monitorowanie i logowanie**:
   - Rejestruj wszystkie Å¼Ä…dania HTTP, szczegÃ³lnie te inicjowane przez serwer, aby wykrywaÄ‡ podejrzane dziaÅ‚ania.

4. **Ograniczenie moÅ¼liwoÅ›ci korzystania z dynamicznych Å¼Ä…daÅ„ HTTP**:
   - JeÅ›li aplikacja nie wymaga dynamicznego tworzenia Å¼Ä…daÅ„ HTTP na podstawie danych uÅ¼ytkownika, rozwaÅ¼ ich caÅ‚kowite wyÅ‚Ä…czenie.

5. **Regularne testowanie bezpieczeÅ„stwa**:
   - WdraÅ¼aj testy bezpieczeÅ„stwa w procesie CI/CD, aby identyfikowaÄ‡ i eliminowaÄ‡ podatnoÅ›ci zwiÄ…zane z SSRF.

</details>

